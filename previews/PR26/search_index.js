var documenterSearchIndex = {"docs":
[{"location":"91-dev_docs/#dev_docs","page":"Developer docs","title":"Developer documentation","text":"","category":"section"},{"location":"91-dev_docs/","page":"Developer docs","title":"Developer docs","text":"note: Contributing guidelines\nIf you haven't, please read the Contributing guidelines first.","category":"page"},{"location":"91-dev_docs/","page":"Developer docs","title":"Developer docs","text":"If you want to make contributions to this package that involves code, then this guide is for you.","category":"page"},{"location":"91-dev_docs/#First-time-clone","page":"Developer docs","title":"First time clone","text":"","category":"section"},{"location":"91-dev_docs/","page":"Developer docs","title":"Developer docs","text":"tip: If you have writing rights\nIf you have writing rights, you don't have to fork. Instead, simply clone and skip ahead. Whenever upstream is mentioned, use origin instead.","category":"page"},{"location":"91-dev_docs/","page":"Developer docs","title":"Developer docs","text":"If this is the first time you work with this repository, follow the instructions below to clone the repository.","category":"page"},{"location":"91-dev_docs/","page":"Developer docs","title":"Developer docs","text":"Fork this repo\nClone your repo (this will create a git remote called origin)\nAdd this repo as a remote:\nbash  git remote add upstream https://github.com/JuliaHEP/LorentzVectorBase.jl.git","category":"page"},{"location":"91-dev_docs/","page":"Developer docs","title":"Developer docs","text":"This will ensure that you have two remotes in your git: origin and upstream. You will create branches and push to origin, and you will fetch and update your local main branch from upstream.","category":"page"},{"location":"91-dev_docs/#Code-Formatting","page":"Developer docs","title":"Code Formatting","text":"","category":"section"},{"location":"91-dev_docs/","page":"Developer docs","title":"Developer docs","text":"To maintain code consistency, format your code with:","category":"page"},{"location":"91-dev_docs/","page":"Developer docs","title":"Developer docs","text":"julia --project=.formatting -e 'using Pkg; Pkg.instantiate(); include(\".formatting/format_all.jl\")'","category":"page"},{"location":"91-dev_docs/","page":"Developer docs","title":"Developer docs","text":"This ensures adherence to the project's formatting standards.","category":"page"},{"location":"91-dev_docs/#Testing","page":"Developer docs","title":"Testing","text":"","category":"section"},{"location":"91-dev_docs/","page":"Developer docs","title":"Developer docs","text":"As with most Julia packages, you can just open Julia in the repository folder, activate the environment, and run test:","category":"page"},{"location":"91-dev_docs/","page":"Developer docs","title":"Developer docs","text":"julia> # press ]\npkg> activate .\npkg> test","category":"page"},{"location":"91-dev_docs/#Working-on-a-new-issue","page":"Developer docs","title":"Working on a new issue","text":"","category":"section"},{"location":"91-dev_docs/","page":"Developer docs","title":"Developer docs","text":"We try to keep a linear history in this repo, so it is important to keep your branches up-to-date.","category":"page"},{"location":"91-dev_docs/","page":"Developer docs","title":"Developer docs","text":"Fetch from the remote and fast-forward your local main\nbash  git fetch upstream  git switch main  git merge --ff-only upstream/main\nBranch from main to address the issue (see below for naming)\nbash  git switch -c 42-add-answer-universe\nPush the new local branch to your personal remote repository\nbash  git push -u origin 42-add-answer-universe\nCreate a pull request to merge your remote branch into the org main.","category":"page"},{"location":"91-dev_docs/#Branch-naming","page":"Developer docs","title":"Branch naming","text":"","category":"section"},{"location":"91-dev_docs/","page":"Developer docs","title":"Developer docs","text":"If there is an associated issue, add the issue number.\nIf there is no associated issue, and the changes are small, add a prefix such as \"typo\", \"hotfix\", \"small-refactor\", according to the type of update.\nIf the changes are not small and there is no associated issue, then create the issue first, so we can properly discuss the changes.\nUse dash separated imperative wording related to the issue (e.g., 14-add-tests, 15-fix-model, 16-remove-obsolete-files).","category":"page"},{"location":"91-dev_docs/#Commit-message","page":"Developer docs","title":"Commit message","text":"","category":"section"},{"location":"91-dev_docs/","page":"Developer docs","title":"Developer docs","text":"Use imperative or present tense, for instance: Add feature or Fix bug.\nHave informative titles.\nWhen necessary, add a body with details.\nIf there are breaking changes, add the information to the commit message.","category":"page"},{"location":"91-dev_docs/#Before-creating-a-pull-request","page":"Developer docs","title":"Before creating a pull request","text":"","category":"section"},{"location":"91-dev_docs/","page":"Developer docs","title":"Developer docs","text":"tip: Atomic git commits\nTry to create \"atomic git commits\" (recommended reading: The Utopic Git History).","category":"page"},{"location":"91-dev_docs/","page":"Developer docs","title":"Developer docs","text":"Make sure the tests pass.\nMake sure the pre-commit tests pass.\nFetch any main updates from upstream and rebase your branch, if necessary:\nbash   git fetch upstream   git rebase upstream/main BRANCH_NAME\nThen you can open a pull request and work with the reviewer to address any issues.","category":"page"},{"location":"91-dev_docs/#Building-and-viewing-the-documentation-locally","page":"Developer docs","title":"Building and viewing the documentation locally","text":"","category":"section"},{"location":"91-dev_docs/","page":"Developer docs","title":"Developer docs","text":"Following the latest suggestions, we recommend using LiveServer to build the documentation. Here is how you do it:","category":"page"},{"location":"91-dev_docs/","page":"Developer docs","title":"Developer docs","text":"Run julia --project=docs to open Julia in the environment of the docs.\nIf this is the first time building the docs\nPress ] to enter pkg mode\nRun pkg> dev . to use the development version of your package\nPress backspace to leave pkg mode\nRun julia> using LiveServer\nRun julia> servedocs()","category":"page"},{"location":"91-dev_docs/#Making-a-new-release","page":"Developer docs","title":"Making a new release","text":"","category":"section"},{"location":"91-dev_docs/","page":"Developer docs","title":"Developer docs","text":"To create a new release, you can follow these simple steps:","category":"page"},{"location":"91-dev_docs/","page":"Developer docs","title":"Developer docs","text":"Create a branch release-x.y.z\nUpdate version in Project.toml\nUpdate the CHANGELOG.md:\nRename the section \"Unreleased\" to \"[x.y.z] - yyyy-mm-dd\" (i.e., version under brackets, dash, and date in ISO format)\nAdd a new section on top of it named \"Unreleased\"\nAdd a new link in the bottom for version \"x.y.z\"\nChange the \"[unreleased]\" link to use the latest version - end of line, vx.y.z ... HEAD.\nCreate a commit \"Release vx.y.z\", push, create a PR, wait for it to pass, merge the PR.\nGo back to main screen and click on the latest commit (link: https://github.com/JuliaHEP/LorentzVectorBase.jl/commit/main)\nAt the bottom, write @JuliaRegistrator register","category":"page"},{"location":"91-dev_docs/","page":"Developer docs","title":"Developer docs","text":"After that, you only need to wait and verify:","category":"page"},{"location":"91-dev_docs/","page":"Developer docs","title":"Developer docs","text":"Wait for the bot to comment (should take < 1m) with a link to a PR to the registry\nFollow the link and wait for a comment on the auto-merge\nThe comment should said all is well and auto-merge should occur shortly\nAfter the merge happens, TagBot will trigger and create a new GitHub tag. Check on https://github.com/JuliaHEP/LorentzVectorBase.jl/releases\nAfter the release is create, a \"docs\" GitHub action will start for the tag.\nAfter it passes, a deploy action will run.\nAfter that runs, the stable docs should be updated. Check them and look for the version number.","category":"page"},{"location":"95-reference/#reference","page":"API Reference","title":"Reference","text":"","category":"section"},{"location":"95-reference/#Contents","page":"API Reference","title":"Contents","text":"","category":"section"},{"location":"95-reference/","page":"API Reference","title":"API Reference","text":"Pages = [\"95-reference.md\"]","category":"page"},{"location":"95-reference/#Index","page":"API Reference","title":"Index","text":"","category":"section"},{"location":"95-reference/","page":"API Reference","title":"API Reference","text":"Pages = [\"95-reference.md\"]","category":"page"},{"location":"95-reference/#Interface","page":"API Reference","title":"Interface","text":"","category":"section"},{"location":"95-reference/#LorentzVectorBase.coordinate_system","page":"API Reference","title":"LorentzVectorBase.coordinate_system","text":"coordinate_system(::MomType)::CS where {CS <: AbstractCoordinateSystem}\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.coordinate_names","page":"API Reference","title":"LorentzVectorBase.coordinate_names","text":"coordinate_names(::AbstractCoordinateSystem)::Tuple{Symbols}\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#Supported-coordinate-systems","page":"API Reference","title":"Supported coordinate systems","text":"","category":"section"},{"location":"95-reference/#LorentzVectorBase.XYZT","page":"API Reference","title":"LorentzVectorBase.XYZT","text":"XYZT <: AbstractCoordinateSystem\n\nRepresents the Cartesian coordinate system for four-vectors, where the components are labeled as (x, y, z, t).\n\nTo use this coordinate system with a custom four-vector type, you must implement the following interface methods:\n\nLorentzVectorBase.x(::CustomFourVector)  # Returns the x-component\nLorentzVectorBase.y(::CustomFourVector)  # Returns the y-component\nLorentzVectorBase.z(::CustomFourVector)  # Returns the z-component\nLorentzVectorBase.t(::CustomFourVector)  # Returns the time component\n\nExample\n\nThe following example demonstrates how to define a custom four-vector type and implement the required interface:\n\njulia> struct CustomLVector\n           x\n           y\n           z\n           t\n       end\n\njulia> LorentzVectorBase.coordinate_system(::CustomLVector) = LorentzVectorBase.XYZT()\n\njulia> LorentzVectorBase.x(lv::CustomLVector) = lv.x\n\njulia> LorentzVectorBase.y(lv::CustomLVector) = lv.y\n\njulia> LorentzVectorBase.z(lv::CustomLVector) = lv.z\n\njulia> LorentzVectorBase.t(lv::CustomLVector) = lv.t\n\njulia> c = CustomLVector(1, 2, 3, 4)\nCustomLVector(1, 2, 3, 4)\n\njulia> @assert isapprox(LorentzVectorBase.spatial_magnitude(c), sqrt(1^2 + 2^2 + 3^2))\n\n\nBy implementing these methods, the custom type CustomLVector becomes compatible with LorentzVectorBase operations in the XYZT coordinate system.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LorentzVectorBase.PxPyPzE","page":"API Reference","title":"LorentzVectorBase.PxPyPzE","text":"PxPyPzE <: AbstractCoordinateSystem\n\nRepresents the Cartesian coordinate system for four-momenta, where the components are labeled as (px, py, pz, E). This system is commonly used in high-energy physics to describe the momentum and energy of particles.\n\nTo use this coordinate system with a custom four-momentum type, you must implement the following interface methods:\n\nLorentzVectorBase.px(::CustomFourMomentum)  # Returns the x-component of momentum\nLorentzVectorBase.py(::CustomFourMomentum)  # Returns the y-component of momentum\nLorentzVectorBase.pz(::CustomFourMomentum)  # Returns the z-component of momentum\nLorentzVectorBase.E(::CustomFourMomentum)   # Returns the energy component\n\nExample\n\nThe following example demonstrates how to define a custom four-momentum type and implement the required interface:\n\njulia> struct CustomFourMomentum\n           px\n           py\n           pz\n           E\n       end\n\njulia> LorentzVectorBase.coordinate_system(::CustomFourMomentum) = LorentzVectorBase.PxPyPzE()\n\njulia> LorentzVectorBase.px(p::CustomFourMomentum) = p.px\n\njulia> LorentzVectorBase.py(p::CustomFourMomentum) = p.py\n\njulia> LorentzVectorBase.pz(p::CustomFourMomentum) = p.pz\n\njulia> LorentzVectorBase.E(p::CustomFourMomentum) = p.E\n\njulia> p = CustomFourMomentum(1.0, 2.0, 3.0, 4.0)\nCustomFourMomentum(1.0, 2.0, 3.0, 4.0)\n\njulia> isapprox(LorentzVectorBase.spatial_magnitude(p), sqrt(1.0^2 + 2.0^2 + 3.0^2))\ntrue\n\n\nBy implementing these methods, the custom type CustomFourMomentum becomes compatible with LorentzVectorBase operations in the PxPyPzE coordinate system.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LorentzVectorBase.PtEtaPhiM","page":"API Reference","title":"LorentzVectorBase.PtEtaPhiM","text":"PtEtaPhiM <: AbstractCoordinateSystem\n\nRepresents the cylindrical coordinate system for four-momenta, commonly used in high-energy physics. This system expresses four-momentum components in terms of transverse momentum (pt), pseudorapidity (eta), azimuthal angle (phi), and mass (mass).\n\nTo use this coordinate system with a custom four-momentum type, you must implement the following interface methods:\n\nLorentzVectorBase.pt(::CustomFourMomentum)    # Returns the transverse momentum\nLorentzVectorBase.eta(::CustomFourMomentum)   # Returns the pseudorapidity\nLorentzVectorBase.phi(::CustomFourMomentum)   # Returns the azimuthal angle\nLorentzVectorBase.mass(::CustomFourMomentum)  # Returns the mass\n\nExample\n\nThe following example demonstrates how to define a custom four-momentum type and implement the required interface:\n\njulia> struct CustomFourMomentum\n           pt\n           eta\n           phi\n           mass\n       end\n\njulia> LorentzVectorBase.coordinate_system(::CustomFourMomentum) = LorentzVectorBase.PtEtaPhiM()\n\njulia> LorentzVectorBase.pt(p::CustomFourMomentum) = p.pt\n\njulia> LorentzVectorBase.eta(p::CustomFourMomentum) = p.eta\n\njulia> LorentzVectorBase.phi(p::CustomFourMomentum) = p.phi\n\njulia> LorentzVectorBase.mass(p::CustomFourMomentum) = p.mass\n\njulia> p = CustomFourMomentum(10.0, 2.5, 1.57, 0.105)\nCustomFourMomentum(10.0, 2.5, 1.57, 0.105)\n\njulia> isapprox(LorentzVectorBase.polar_angle(p), 2 * atan(exp(-2.5)))\ntrue\n\n\nBy implementing these methods, the custom type CustomFourMomentum becomes compatible with LorentzVectorBase operations in the PtEtaPhiM coordinate system.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#Supported-getter-functions","page":"API Reference","title":"Supported getter functions","text":"","category":"section"},{"location":"95-reference/#LorentzVectorBase.x","page":"API Reference","title":"LorentzVectorBase.x","text":"x(lv)\n\nReturn the x-component (first spatial component) of the Lorentz-vector-like lv.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.y","page":"API Reference","title":"LorentzVectorBase.y","text":"y(lv)\n\nReturn the y-component (second spatial component) of the Lorentz-vector-like lv.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.z","page":"API Reference","title":"LorentzVectorBase.z","text":"z(lv)\n\nReturn the z-component (third spatial component) of the Lorentz-vector-like lv.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.t","page":"API Reference","title":"LorentzVectorBase.t","text":"t(lv)\n\nReturn the time (energy) component of the Lorentz-vector-like lv.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.px","page":"API Reference","title":"LorentzVectorBase.px","text":"px(lv)\n\nReturn the x-component of a given Lorentz-vector-like lv.\n\nExample\n\nFor a four-momentum `(px, py, pz, E)`, this function returns the `px` component.\n\nSee Also\n\nLorentzVectorBase.x: The x-component of a Lorentz-vector-like, which is equivalent to px.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.py","page":"API Reference","title":"LorentzVectorBase.py","text":"py(lv)\n\nReturn the y-component of a given Lorentz-vector-like lv.\n\nExample\n\nFor a four-momentum (px, py, pz, E), this function returns the py component.\n\nSee Also\n\nLorentzVectorBase.y: The y-component of a Lorentz-vector-like, which is equivalent to py.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.pz","page":"API Reference","title":"LorentzVectorBase.pz","text":"pz(lv)\n\nReturn the z-component of a given Lorentz-vector-like lv.\n\nExample\n\nFor a four-momentum (px, py, pz, E), this function returns the pz component.\n\nSee Also\n\nLorentzVectorBase.z: The z-component of a Lorentz-vector-like, which is equivalent to pz.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.E","page":"API Reference","title":"LorentzVectorBase.E","text":"E(lv)\n\nReturn the energy component (E) of a given Lorentz-vector-like lv.\n\nExample\n\nFor a four-momentum (px, py, pz, E), this function returns the E component.\n\nSee Also\n\nLorentzVectorBase.t: The time component of a Lorentz-vector-like, which is equivalent to E.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.pt","page":"API Reference","title":"LorentzVectorBase.pt","text":"pt(lv)\n\nReturn the transverse momentum (p_T) of a given Lorentz-vector-like lv, defined as the Euclidean magnitude of the momentum components in the x-y plane.\n\nExample\n\nFor a four-momentum (px, py, pz, E), this function returns sqrt(px^2 + py^2).\n\nNotes\n\nThe transverse components are defined with respect to the z-axis (3-axis), representing the perpendicular momentum to this axis.\n\nSee Also\n\npt2: For the squared transverse momentum.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.pt2","page":"API Reference","title":"LorentzVectorBase.pt2","text":"pt2(lv)\n\nReturn the squared transverse momentum (p_T^2) of a given Lorentz-vector-like lv. The transverse momentum is defined with respect to the z-axis (3-axis) and is the sum of the squares of the x- and y-components.\n\nExample\n\nFor a four-momentum (px, py, pz, E), this function returns px^2 + py^2.\n\nNotes\n\nThe transverse components are the momentum projections in the x-y plane, perpendicular to the z-axis.\n\nSee Also\n\npt: For the transverse momentum.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.eta","page":"API Reference","title":"LorentzVectorBase.eta","text":"eta(lv)\n\nReturn the pseudorapidity (eta) of a given Lorentz-vector-like lv. The pseudorapidity is a commonly used quantity in high-energy physics, particularly in collider experiments, and is defined as:\n\n    eta = -log(tan(theta 2))\n\nwhere theta is the polar angle of the Lorentz-vector-like relative to the z-axis.\n\nExample\n\nFor a four-momentum (px, py, pz, E), this function log(tan(theta/2)) where theta is given by the polar_angle.\n\nwarning: Warning\nIf the transverse momentum (pt) is zero (i.e., the particle is aligned with the beam axis), a warning is raised, and a large pseudorapidity value (±10e10) is returned as a convention. This occurs because the pseudorapidity is ill-defined when pt = 0.\n\nNotes\n\nPseudorapidity is approximately equal to the rapidity y in the ultra-relativistic limit   (when the particle's mass is negligible compared to its energy).\n\nSee Also\n\nrapidity: For the rapidity of the Lorentz-vector-like.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.phi","page":"API Reference","title":"LorentzVectorBase.phi","text":"phi(lv)\n\nReturn the azimuthal angle (phi) of the Lorentz-vector-like lv.\n\nThe azimuthal angle is the angle between the x-axis and the projection of the Lorentz-vector-like on the x-y plane.\n\nExample\n\nIf ``(x, y, z, t)`` is a four-vector, this is equivalent to ``atan(y / x)``.\n\nnote: Note\nThe azimuthal angle is defined with respect to the z-axis.\n\nSee Also\n\nLorentzVectorBase.sin_phi: for a faster version of the sine of the azimuthal angle.\nLorentzVectorBase.cos_phi: for a faster version of the cosine of the azimuthal angle.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.spatial_magnitude","page":"API Reference","title":"LorentzVectorBase.spatial_magnitude","text":"spatial_magnitude(lv)\n\nReturn the spatial magnitude of the Lorentz-vector-like lv, i.e., the magnitude of its spatial components.\n\nExample\n\nIf the Lorentz-vector-like is a four-vector (x, y, z, t), this function returns sqrt(x^2 + y^2 + z^2).\n\nwarning: Warning\nThis function differs from the TLorentzVector::P() function in the ROOT library.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.spatial_magnitude2","page":"API Reference","title":"LorentzVectorBase.spatial_magnitude2","text":"spatial_magnitude2(lv)\n\nReturn the square of the spatial magnitude of the Lorentz-vector-like lv, i.e., the sum of the squares of its spatial components.\n\nExample\n\nIf the Lorentz-vector-like is four-vector (x, y, z, t), this function returns x^2 + y^2 + z^2.\n\nwarning: Warning\nThis function differs from the TLorentzVector::P2() function in the ROOT library.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.mass","page":"API Reference","title":"LorentzVectorBase.mass","text":"mass(lv)\n\nReturn the invariant mass  of the Lorentz-vector-like lv, computed as the square root of the Minkowski inner product of the four-vector components with itself.\n\nExample\n\nFor a four-momentum (px, py, pz, E), this function returns sqrt(E^2 - (px^2 + py^2 + pz^2)).\n\nNotes\n\nIf the squared invariant mass m^2 is negative, this function returns -sqrt(-m^2) to ensure a real result. This can happen in certain unphysical cases where the energy component is smaller than the spatial momentum magnitude.\n\nSee Also\n\nmass2: For the squared invariant mass calculation.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.mass2","page":"API Reference","title":"LorentzVectorBase.mass2","text":"mass2(lv)\n\nReturn the squared invariant mass of the Lorentz-vector-like lv, computed as the Minkowski inner product of the four-vector components with itself.\n\nExample\n\nFor a four-momentum (px, py, pz, E), this function returns E^2 - (px^2 + py^2 + pz^2).\n\nSee Also\n\nmass: For the invariant mass, i.e., the square root of this value.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.boost_beta","page":"API Reference","title":"LorentzVectorBase.boost_beta","text":"boost_beta(lv)\n\nReturn the magnitude of the velocity (beta) of a particle as a fraction of the speed of light of the Lorentz-vector-like lv.\n\nExample\n\nFor a four-momentum (px, py, pz, E), this function returns sqrt(px^2 + py^2 + pz^2) / E.\n\nThrows\n\nArgumentError if the time (energy) component is zero while the spatial components are non-zero, as this results in an undefined velocity.\n\nNotes\n\nIf both the time (energy) and spatial components are zero, the function returns zero (beta = 0), as this represents a stationary object with no motion.\n\nSee Also\n\nboost_gamma: For the relativistic gamma factor, which depends on beta.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.boost_gamma","page":"API Reference","title":"LorentzVectorBase.boost_gamma","text":"boost_gamma(lv)\n\nReturn the relativistic gamma factor (gamma) for the Lorentz-vector-like lv.\n\nExample\n\nFor a four-momentum (px, py, pz, E) with velocity beta, this function returns 1  sqrt(1 - beta^2).\n\nSee Also\n\nboost_beta: For the velocity beta, which is used to compute gamma.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.mt2","page":"API Reference","title":"LorentzVectorBase.mt2","text":"mt2(lv)\n\nReturn the squared transverse mass (m_T^2) of a given Lorentz-vector-like lv, which is the difference between the squared time- (energy-) and the squared z-component.\n\nExample\n\nFor a four-momentum (px, py, pz, E), this function returns E^2 - pz^2.\n\nNotes\n\nThe transverse components are defined with respect to the z-axis (3-axis), indicating a projection in the x-y plane.\n\nSee Also\n\nmt: For the transverse mass.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.mt","page":"API Reference","title":"LorentzVectorBase.mt","text":"mt(lv)\n\nReturn the transverse mass (m_T) of a given Lorentz-vector-like lv, calculated as the square root of the squared transverse mass. The transverse mass is often used in high-energy physics to describe the effective mass of a system when only the transverse components are considered.\n\nExample\n\nFor a four-momentum (px, py, pz, E), this function returns sqrt(E^2 - pz^2).\n\nNotes\n\nIf the squared transverse mass (mT^2) is negative, the function returns -sqrt(-mT^2) to\n\nhandle the imaginary mass situation that can occur in some relativistic systems.\n\nThe transverse components are defined with respect to the z-axis (3-axis), indicating momentum in the x-y plane.\n\nThrows\n\nMay include a warning if the transverse mass is negative, depending on user settings.\n\nSee Also\n\nmt2: For the squared transverse mass.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.rapidity","page":"API Reference","title":"LorentzVectorBase.rapidity","text":"rapidity(lv)\n\nReturn the rapidity for a given Lorentz-vector-like lv.\n\nThe rapidity y is defined as:\n\ny = frac12log((E + p_z)  (E - p_z))\n\nwhere E is the energy (time- or 0-component of the Lorentz-vector-like), and pz is the component along the z-axis.\n\nExample\n\nFor a four-vector (px, py, pz, E), this function calculates the rapidity as:\n\ny = 0.5 * log((E + pz) / (E - pz))\n\nNotes\n\nRapidity is preferred over pseudorapidity when mass effects are significant, as it takes   into account the energy and longitudinal momentum of the particle. In contrast, pseudorapidity   depends only on the particle's direction and ignores mass.\nThe transverse components of the momentum are defined with respect to the 3-axis (beam axis).\nRapidity is Lorentz-invariant under boosts along the z-axis, making it useful for comparisons   between different reference frames in collider experiments.\n\nwarning: Warning\nIf the particle's energy E is equal to its longitudinal momentum pz, resulting in a denominator of zero in the logarithm, the function will raise an error as rapidity is ill-defined in this case.\n\nSee Also\n\nLorentzVectorBase.eta: For the pseudorapidity of the Lorentz-vector-like.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.polar_angle","page":"API Reference","title":"LorentzVectorBase.polar_angle","text":"polar_angle(lv)\n\nReturn the polar angle (theta) of the Lorentz-vector-like lv.\n\nExample\n\nIf the Lorentz-vector-like is a four-vector (x y z t), this is equivalent to arccos(z  sqrtx^2 + y^2 + z^2).\n\nnote: Note\nIf the Lorentz-vector-like is zero, the function returns zero for the angle.\n\nSee Also\n\nLorentzVectorBase.cos_theta: for a faster version of the cosine of the polar angle.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.cos_theta","page":"API Reference","title":"LorentzVectorBase.cos_theta","text":"cos_theta(lv)\n\nReturn the cosine of the polar angle (theta) of the Lorentz-vector-like lv.\n\nDepending on the coordinate system, this might be an equivalent but faster version of cos(polar_angle(lv)).\n\nExample\n\nIf (x y z t) is a four-vector, this is equivalent to z  sqrtx^2 + y^2 + z^2.\n\nSee Also\n\nLorentzVectorBase.polar_angle: for the polar angle itself.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.cos_phi","page":"API Reference","title":"LorentzVectorBase.cos_phi","text":"cos_phi(lv)\n\nReturn the cosine of the azimuthal angle (phi) of the Lorentz-vector-like lv.\n\nDepending on the coordinate system, this might be an equivalent but faster version of cos(phi(lv)).\n\nExample\n\nIf (x y z t) is a four-momentum, this is equivalent to x  sqrtx^2 + y^2.\n\nSee Also\n\nLorentzVectorBase.phi: for the azimuthal angle itself.\nLorentzVectorBase.sin_phi: for a faster version of the sine of the azimuthal angle.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.sin_phi","page":"API Reference","title":"LorentzVectorBase.sin_phi","text":"sin_phi(lv)\n\nReturn the sine of the azimuthal angle (phi) of the Lorentz-vector-like lv.\n\nDepending on the coordinate system, this might be an equivalent but faster version of sin(phi(lv)).\n\nExample\n\nIf (x y z t) is a four-momentum, this is equivalent to y  sqrtx^2 + y^2.\n\nSee Also\n\nLorentzVectorBase.phi: for the azimuthal angle itself.\nLorentzVectorBase.cos_phi: for a faster version of the cosine of the azimuthal angle.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.plus_component","page":"API Reference","title":"LorentzVectorBase.plus_component","text":"plus_component(lv)\n\nReturn the plus component (p^+) of the Lorentz-vector-like lv in light-cone coordinates.\n\nThis component is defined as (t + z) / 2, where t is the time (or energy) component and z is the third spatial component of the Lorentz-vector-like.\n\nExample\n\nIf (x, y, z, t) is a four-vector, this is equivalent to (t + z) / 2.\n\nwarning: Warning\nThis definition differs from the light-cone coordinate definitions commonly used in general relativity.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.minus_component","page":"API Reference","title":"LorentzVectorBase.minus_component","text":"minus_component(lv)\n\nReturn the minus component (p^-) of the Lorentz-vector-like lv in light-cone coordinates.\n\nThis component is defined as (t - z) / 2, where t is the time (or energy) component and z is the third spatial component of the Lorentz-vector-like.\n\nExample\n\nIf (x, y, z, t) is a four-vector, this is equivalent to (t - z) / 2.\n\nwarning: Warning\nThis definition differs from the light-cone coordinate definitions commonly used in general relativity.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#Utility","page":"API Reference","title":"Utility","text":"","category":"section"},{"location":"95-reference/#LorentzVectorBase.available_accessors","page":"API Reference","title":"LorentzVectorBase.available_accessors","text":"available_accessors()\n\nReturns a list of available accessor functions for four-momentum components.\n\nThis function gathers all defined accessor methods (such as px, py, pz, E, etc.) that are available for any custom four-momentum type implementing the LorentzVectorBase interface.\n\nExample\n\njulia> LorentzVectorBase.available_accessors()\n38-element Vector{Symbol}:\n :x\n :y\n :z\n :t\n :energy\n :px\n :py\n ...\n\nThis allows users to query which accessor functions are available for any custom four-momentum type.\n\n\n\n\n\n","category":"function"},{"location":"10-interface/#interface","page":"Interface","title":"LorentzVectorBase Interface","text":"","category":"section"},{"location":"10-interface/","page":"Interface","title":"Interface","text":"The LorentzVectorBase package defines a common interface for LorentzVectorBase-compliant types in Julia. This interface allows developers to define their own custom four-vector types (e.g., for particles or kinematic configurations) and automatically gain access to a large suite of common kinematic computations. For maximum flexibility, it is not necessary to inherit from an abstract base type.","category":"page"},{"location":"10-interface/#Purpose","page":"Interface","title":"Purpose","text":"","category":"section"},{"location":"10-interface/","page":"Interface","title":"Interface","text":"The main goal is to provide a lightweight abstraction that enables:","category":"page"},{"location":"10-interface/","page":"Interface","title":"Interface","text":"Interoperability between different packages using Lorentz vectors\nAutomatic derivation of many derived quantities (e.g. p_T, eta, m) from a minimal interface\nCoordinate system flexibility while maintaining performance","category":"page"},{"location":"10-interface/#Defining-a-Lorentz-Vector-Like-Type","page":"Interface","title":"Defining a Lorentz-Vector-Like Type","text":"","category":"section"},{"location":"10-interface/","page":"Interface","title":"Interface","text":"To make your type compliant with LorentzVectorBase, you must:","category":"page"},{"location":"10-interface/","page":"Interface","title":"Interface","text":"Assign a coordinate system using:","category":"page"},{"location":"10-interface/","page":"Interface","title":"Interface","text":"LorentzVectorBase.coordinate_system(::Type{MyVector}) = XYZT()","category":"page"},{"location":"10-interface/","page":"Interface","title":"Interface","text":"Coordinate systems are tagged using constructors like XYZT(), PtEtaPhiE(), etc. These indicate how the four components are interpreted.","category":"page"},{"location":"10-interface/","page":"Interface","title":"Interface","text":"Implement the four accessors required by the chosen coordinate system.","category":"page"},{"location":"10-interface/","page":"Interface","title":"Interface","text":"For example, with XYZT():","category":"page"},{"location":"10-interface/","page":"Interface","title":"Interface","text":"x(::MyVector)\ny(::MyVector)\nz(::MyVector)\nt(::MyVector)","category":"page"},{"location":"10-interface/","page":"Interface","title":"Interface","text":"You can inspect the required accessors for a given coordinate system using:","category":"page"},{"location":"10-interface/","page":"Interface","title":"Interface","text":"coordinate_system(XYZT())  # returns (:x, :y, :z, :t)","category":"page"},{"location":"10-interface/","page":"Interface","title":"Interface","text":"This indicates which component accessors your type must implement to be compliant with that system.","category":"page"},{"location":"10-interface/","page":"Interface","title":"Interface","text":"That's it! Once those are defined, the LorentzVectorBase package will automatically provide implementations for a wide variety of additional kinematic functions and coordinate conversions.","category":"page"},{"location":"10-interface/#getter","page":"Interface","title":"What You Get Automatically","text":"","category":"section"},{"location":"10-interface/","page":"Interface","title":"Interface","text":"Once a minimal interface is implemented, the following functions become available (among others), categorized by topic:","category":"page"},{"location":"10-interface/#Cartesian-Components","page":"Interface","title":"Cartesian Components","text":"","category":"section"},{"location":"10-interface/","page":"Interface","title":"Interface","text":"x, y, z, t\npx, py, pz, E","category":"page"},{"location":"10-interface/#Spherical-and-Cylindrical-Coordinates","page":"Interface","title":"Spherical and Cylindrical Coordinates","text":"","category":"section"},{"location":"10-interface/","page":"Interface","title":"Interface","text":"spatial_magnitude, spatial_magnitude2\npolar_angle, cos_theta\nphi, cos_phi, sin_phi","category":"page"},{"location":"10-interface/#Mass-and-Invariant-Quantities","page":"Interface","title":"Mass and Invariant Quantities","text":"","category":"section"},{"location":"10-interface/","page":"Interface","title":"Interface","text":"mass, mass2\nmt, mt2\npt, pt2","category":"page"},{"location":"10-interface/#Rapidity-and-Related-Quantities","page":"Interface","title":"Rapidity and Related Quantities","text":"","category":"section"},{"location":"10-interface/","page":"Interface","title":"Interface","text":"eta: pseudorapidity\nrapidity","category":"page"},{"location":"10-interface/#Boost-Parameters","page":"Interface","title":"Boost Parameters","text":"","category":"section"},{"location":"10-interface/","page":"Interface","title":"Interface","text":"boost_beta, boost_gamma","category":"page"},{"location":"10-interface/#Light-Cone-Coordinates","page":"Interface","title":"Light-Cone Coordinates","text":"","category":"section"},{"location":"10-interface/","page":"Interface","title":"Interface","text":"plus_component, minus_component","category":"page"},{"location":"10-interface/#Accessor-Aliases","page":"Interface","title":"Accessor Aliases","text":"","category":"section"},{"location":"10-interface/","page":"Interface","title":"Interface","text":"To improve readability and interoperability, LorentzVectorBase provides a set of aliases for common physics terminology. These aliases map frequently used or alternative names to the canonical accessor functions.","category":"page"},{"location":"10-interface/","page":"Interface","title":"Interface","text":"For example, energy is an alias for t, and invariant_mass maps to mass.","category":"page"},{"location":"10-interface/","page":"Interface","title":"Interface","text":"energy(lv)           === t(lv)\ninvariant_mass(lv)   === mass(lv)\ntransverse_momentum(lv) === pt(lv)","category":"page"},{"location":"10-interface/","page":"Interface","title":"Interface","text":"This allows users to choose more descriptive or domain-specific terminology without losing compatibility.","category":"page"},{"location":"10-interface/#Available-Aliases","page":"Interface","title":"Available Aliases","text":"","category":"section"},{"location":"10-interface/","page":"Interface","title":"Interface","text":"Alias Canonical Function\nenergy t\ninvariant_mass mass\ninvariant_mass2 mass2\ntransverse_momentum pt\ntransverse_momentum2 pt2\nperp pt\nperp2 pt2\ntransverse_mass mt\ntransverse_mass2 mt2\nazimuthal_angle phi\npseudorapidity eta","category":"page"},{"location":"10-interface/#Coordinate-System-Tags","page":"Interface","title":"Coordinate System Tags","text":"","category":"section"},{"location":"10-interface/","page":"Interface","title":"Interface","text":"The following coordinate systems are supported via tags like XYZT(), PtEtaPhiM(), etc.:","category":"page"},{"location":"10-interface/","page":"Interface","title":"Interface","text":"XYZT, PxPyPzE — position/time or cartesian four-momentum\nPtEtaPhiM — common in collider physics","category":"page"},{"location":"10-interface/","page":"Interface","title":"Interface","text":"Each tag specifies which component names (x, pt, eta, etc.) you must implement.","category":"page"},{"location":"10-interface/#Example","page":"Interface","title":"Example","text":"","category":"section"},{"location":"10-interface/","page":"Interface","title":"Interface","text":"struct MyVector\n    px::Float64\n    py::Float64\n    pz::Float64\n    E::Float64\nend\n\nLorentzVectorBase.coordinate_system(::Type{MyVector}) = XYZE()\n\nLorentzVectorBase.px(v::MyVector) = v.px\nLorentzVectorBase.py(v::MyVector) = v.py\nLorentzVectorBase.pz(v::MyVector) = v.pz\nLorentzVectorBase.energy(v::MyVector) = v.E","category":"page"},{"location":"10-interface/","page":"Interface","title":"Interface","text":"Now your type supports:","category":"page"},{"location":"10-interface/","page":"Interface","title":"Interface","text":"mass(MyVector(...))\neta(MyVector(...))\npt(MyVector(...))\nphi(MyVector(...))","category":"page"},{"location":"10-interface/","page":"Interface","title":"Interface","text":"without implementing them manually.","category":"page"},{"location":"generated/20-new_four_vector/#Implementing-the-LorentzVectorBase-Interface","page":"New Four-Vector","title":"Implementing the LorentzVectorBase Interface","text":"","category":"section"},{"location":"generated/20-new_four_vector/","page":"New Four-Vector","title":"New Four-Vector","text":"This tutorial demonstrates how to make a custom Julia type compatible with the LorentzVectorBase interface. Once your type implements the minimal required methods, you gain access to a rich suite of automatically derived kinematic functions such as mass, pt, rapidity, phi, and many others. See here for a complete list.","category":"page"},{"location":"generated/20-new_four_vector/#Step-1:-Load-the-package","page":"New Four-Vector","title":"Step 1: Load the package","text":"","category":"section"},{"location":"generated/20-new_four_vector/","page":"New Four-Vector","title":"New Four-Vector","text":"using LorentzVectorBase","category":"page"},{"location":"generated/20-new_four_vector/#Step-2:-Define-your-custom-Lorentz-vector-type","page":"New Four-Vector","title":"Step 2: Define your custom Lorentz vector type","text":"","category":"section"},{"location":"generated/20-new_four_vector/","page":"New Four-Vector","title":"New Four-Vector","text":"Let's define a simple concrete type representing a four-momentum vector using Cartesian coordinates: x, y, z, and t.","category":"page"},{"location":"generated/20-new_four_vector/","page":"New Four-Vector","title":"New Four-Vector","text":"struct MyVector\n  x::Float64\n  y::Float64\n  z::Float64\n  t::Float64\nend","category":"page"},{"location":"generated/20-new_four_vector/#Step-3:-Specify-the-coordinate-system","page":"New Four-Vector","title":"Step 3: Specify the coordinate system","text":"","category":"section"},{"location":"generated/20-new_four_vector/","page":"New Four-Vector","title":"New Four-Vector","text":"Next, we tell LorentzVectorBase which coordinate system our type uses. Since MyVector stores its components in Cartesian momentum form, we declare:","category":"page"},{"location":"generated/20-new_four_vector/","page":"New Four-Vector","title":"New Four-Vector","text":"LorentzVectorBase.coordinate_system(::MyVector) = LorentzVectorBase.XYZT()","category":"page"},{"location":"generated/20-new_four_vector/","page":"New Four-Vector","title":"New Four-Vector","text":"The tag XYZT() indicates a four-momentum representation with components (x, y, z, t).","category":"page"},{"location":"generated/20-new_four_vector/#Step-4:-Implement-the-required-accessors","page":"New Four-Vector","title":"Step 4: Implement the required accessors","text":"","category":"section"},{"location":"generated/20-new_four_vector/","page":"New Four-Vector","title":"New Four-Vector","text":"Finally, we provide methods to extract the components expected by the XYZT coordinate system: x, y, z, and t.","category":"page"},{"location":"generated/20-new_four_vector/","page":"New Four-Vector","title":"New Four-Vector","text":"LorentzVectorBase.x(v::MyVector) = v.x\nLorentzVectorBase.y(v::MyVector) = v.y\nLorentzVectorBase.z(v::MyVector) = v.z\nLorentzVectorBase.t(v::MyVector) = v.t","category":"page"},{"location":"generated/20-new_four_vector/","page":"New Four-Vector","title":"New Four-Vector","text":"With these definitions in place, MyVector now fully satisfies the LorentzVectorBase interface!","category":"page"},{"location":"generated/20-new_four_vector/#Step-5:-Use-the-derived-functionality","page":"New Four-Vector","title":"Step 5: Use the derived functionality","text":"","category":"section"},{"location":"generated/20-new_four_vector/","page":"New Four-Vector","title":"New Four-Vector","text":"Let's create an instance of our custom type and use some of the functionality that LorentzVectorBase now provides for free:","category":"page"},{"location":"generated/20-new_four_vector/","page":"New Four-Vector","title":"New Four-Vector","text":"using LorentzVectorBase: mass, pt, eta, rapidity, phi\n\nv = MyVector(1.0, 2.0, 3.0, 4.0)\n\nmass(v) # Invariant mass\npt(v) # Transverse momentum\neta(v) # Pseudorapidity\nrapidity(v) # Rapidity\nphi(v) # Azimuthal angle","category":"page"},{"location":"generated/20-new_four_vector/#Optional:-Use-aliases-for-convenience","page":"New Four-Vector","title":"Optional: Use aliases for convenience","text":"","category":"section"},{"location":"generated/20-new_four_vector/","page":"New Four-Vector","title":"New Four-Vector","text":"The package also defines aliases like energy, invariant_mass, and transverse_momentum. These are mapped automatically to their canonical counterparts:","category":"page"},{"location":"generated/20-new_four_vector/","page":"New Four-Vector","title":"New Four-Vector","text":"using LorentzVectorBase: energy, invariant_mass, transverse_momentum\n\nenergy(v) # Same as `t(v)` or `E(v)`\ninvariant_mass(v) # Same as `mass(v)`\ntransverse_momentum(v) # Same as `pt(v)`","category":"page"},{"location":"generated/20-new_four_vector/","page":"New Four-Vector","title":"New Four-Vector","text":"","category":"page"},{"location":"generated/20-new_four_vector/","page":"New Four-Vector","title":"New Four-Vector","text":"This page was generated using Literate.jl.","category":"page"},{"location":"generated/21-new_coord_system/#Implementing-a-New-Coordinate-System-in-LorentzVectorBase.jl","page":"New Coordinate System","title":"Implementing a New Coordinate System in LorentzVectorBase.jl","text":"","category":"section"},{"location":"generated/21-new_coord_system/","page":"New Coordinate System","title":"New Coordinate System","text":"In LorentzVectorBase.jl, coordinate systems are independent of any concrete four-vector type.","category":"page"},{"location":"generated/21-new_coord_system/","page":"New Coordinate System","title":"New Coordinate System","text":"This tutorial shows how to implement a light-cone coordinate system for four-momentum, so that any Lorentz vector type can use it — provided that type implements the coordinate-specific getter functions.","category":"page"},{"location":"generated/21-new_coord_system/#Light-cone-coordinates","page":"New Coordinate System","title":"Light-cone coordinates","text":"","category":"section"},{"location":"generated/21-new_coord_system/","page":"New Coordinate System","title":"New Coordinate System","text":"We'll define:","category":"page"},{"location":"generated/21-new_coord_system/","page":"New Coordinate System","title":"New Coordinate System","text":"plus_component  = (t + z) / √2\nminus_component = (t - z) / √2\nx\ny","category":"page"},{"location":"generated/21-new_coord_system/","page":"New Coordinate System","title":"New Coordinate System","text":"The coordinate-specific getters will be:","category":"page"},{"location":"generated/21-new_coord_system/","page":"New Coordinate System","title":"New Coordinate System","text":"LorentzVectorBase.plus_component(v)\nLorentzVectorBase.minus_component(v)\nLorentzVectorBase.x(v)\nLorentzVectorBase.y(v)","category":"page"},{"location":"generated/21-new_coord_system/","page":"New Coordinate System","title":"New Coordinate System","text":"All other kinematic quantities (mass, pt, eta, phi, etc.) will be defined once in the coordinate system and will work for any vector type implementing the coordinate getters.","category":"page"},{"location":"generated/21-new_coord_system/","page":"New Coordinate System","title":"New Coordinate System","text":"using LorentzVectorBase","category":"page"},{"location":"generated/21-new_coord_system/#1.-Define-the-coordinate-system-type","page":"New Coordinate System","title":"1. Define the coordinate system type","text":"","category":"section"},{"location":"generated/21-new_coord_system/","page":"New Coordinate System","title":"New Coordinate System","text":"Coordinate systems are singletons and must be subtypes of AbstractCoordinateSystem.","category":"page"},{"location":"generated/21-new_coord_system/","page":"New Coordinate System","title":"New Coordinate System","text":"struct LightConeCoordinates <: LorentzVectorBase.AbstractCoordinateSystem end","category":"page"},{"location":"generated/21-new_coord_system/#2.-Define-the-coordinate-names","page":"New Coordinate System","title":"2. Define the coordinate names","text":"","category":"section"},{"location":"generated/21-new_coord_system/","page":"New Coordinate System","title":"New Coordinate System","text":"coordinate_names returns the tuple of getter function names that must be implemented for any vector type using this coordinate system.","category":"page"},{"location":"generated/21-new_coord_system/","page":"New Coordinate System","title":"New Coordinate System","text":"function LorentzVectorBase.coordinate_names(::LightConeCoordinates)\n  (:plus_component, :minus_component, :x, :y)\nend","category":"page"},{"location":"generated/21-new_coord_system/#3.-Implement-the-derived-kinematic-functions","page":"New Coordinate System","title":"3. Implement the derived kinematic functions","text":"","category":"section"},{"location":"generated/21-new_coord_system/","page":"New Coordinate System","title":"New Coordinate System","text":"The coordinate system must implement all relevant getter functions listed in FOURMOMENTUM_GETTER_FUNCTIONS, except those returned by coordinate_names.","category":"page"},{"location":"generated/21-new_coord_system/","page":"New Coordinate System","title":"New Coordinate System","text":"These implementations are type-generic — they take a coordinate system instance and a mom (momentum object), and call only the coordinate-specific getters (plus_component, minus_component, x, y).","category":"page"},{"location":"generated/21-new_coord_system/","page":"New Coordinate System","title":"New Coordinate System","text":"const SQRT2 = sqrt(2.0)","category":"page"},{"location":"generated/21-new_coord_system/","page":"New Coordinate System","title":"New Coordinate System","text":"Cartesian component accessors","category":"page"},{"location":"generated/21-new_coord_system/","page":"New Coordinate System","title":"New Coordinate System","text":"function LorentzVectorBase.t(::LightConeCoordinates, mom)\n  (plus_component(mom) + minus_component(mom)) / SQRT2\nend\nfunction LorentzVectorBase.z(::LightConeCoordinates, mom)\n  (plus_component(mom) - minus_component(mom)) / SQRT2\nend","category":"page"},{"location":"generated/21-new_coord_system/","page":"New Coordinate System","title":"New Coordinate System","text":"Momentum magnitudes","category":"page"},{"location":"generated/21-new_coord_system/","page":"New Coordinate System","title":"New Coordinate System","text":"LorentzVectorBase.px(::LightConeCoordinates, mom) = p_x(mom)\nLorentzVectorBase.py(::LightConeCoordinates, mom) = p_y(mom)\nfunction LorentzVectorBase.pz(::LightConeCoordinates, mom)\n  (plus_component(mom) - minus_component(mom)) / SQRT2\nend\nfunction LorentzVectorBase.E(::LightConeCoordinates, mom)\n  (plus_component(mom) + minus_component(mom)) / SQRT2\nend\n\nLorentzVectorBase.pt2(::LightConeCoordinates, mom) = p_x(mom)^2 + p_y(mom)^2\nLorentzVectorBase.pt(cs::LightConeCoordinates, mom) = sqrt(LorentzVectorBase.pt2(cs, mom))\n\nfunction LorentzVectorBase.spatial_magnitude2(cs::LightConeCoordinates, mom)\n  LorentzVectorBase.pt2(cs, mom) + LorentzVectorBase.pz(cs, mom)^2\nend\nfunction LorentzVectorBase.spatial_magnitude(cs::LightConeCoordinates, mom)\n  sqrt(LorentzVectorBase.spatial_magnitude2(cs, mom))\nend","category":"page"},{"location":"generated/21-new_coord_system/","page":"New Coordinate System","title":"New Coordinate System","text":"Mass and energy-related","category":"page"},{"location":"generated/21-new_coord_system/","page":"New Coordinate System","title":"New Coordinate System","text":"function LorentzVectorBase.mass2(cs::LightConeCoordinates, mom)\n  LorentzVectorBase.E(cs, mom)^2 - LorentzVectorBase.spatial_magnitude2(cs, mom)\nend\nfunction LorentzVectorBase.mass(cs::LightConeCoordinates, mom)\n  sqrt(LorentzVectorBase.mass2(cs, mom))\nend\n\nfunction LorentzVectorBase.boost_beta(cs::LightConeCoordinates, mom)\n  LorentzVectorBase.spatial_magnitude(cs, mom) / LorentzVectorBase.E(cs, mom)\nend\nfunction LorentzVectorBase.boost_gamma(cs::LightConeCoordinates, mom)\n  1 / sqrt(1 - LorentzVectorBase.boost_beta(cs, mom)^2)\nend\n\nfunction LorentzVectorBase.mt2(cs::LightConeCoordinates, mom)\n  LorentzVectorBase.E(cs, mom)^2 - LorentzVectorBase.pz(cs, mom)^2\nend\nLorentzVectorBase.mt(cs::LightConeCoordinates, mom) = sqrt(LorentzVectorBase.mt2(cs, mom))","category":"page"},{"location":"generated/21-new_coord_system/","page":"New Coordinate System","title":"New Coordinate System","text":"Angular coordinates","category":"page"},{"location":"generated/21-new_coord_system/","page":"New Coordinate System","title":"New Coordinate System","text":"function LorentzVectorBase.rapidity(cs::LightConeCoordinates, mom)\n  0.5 * log(\n    (LorentzVectorBase.E(cs, mom) + LorentzVectorBase.pz(cs, mom)) /\n    (LorentzVectorBase.E(cs, mom) - LorentzVectorBase.pz(cs, mom)),\n  )\nend\n\nfunction LorentzVectorBase.polar_angle(cs::LightConeCoordinates, mom)\n  atan(LorentzVectorBase.pt(cs, mom), LorentzVectorBase.pz(cs, mom))\nend\n\nfunction LorentzVectorBase.cos_theta(cs::LightConeCoordinates, mom)\n  LorentzVectorBase.pz(cs, mom) / LorentzVectorBase.spatial_magnitude(cs, mom)\nend\n\nfunction LorentzVectorBase.phi(cs::LightConeCoordinates, mom)\n  atan(LorentzVectorBase.py(cs, mom), LorentzVectorBase.px(cs, mom))\nend\nfunction LorentzVectorBase.cos_phi(cs::LightConeCoordinates, mom)\n  LorentzVectorBase.px(cs, mom) / LorentzVectorBase.pt(cs, mom)\nend\nfunction LorentzVectorBase.sin_phi(cs::LightConeCoordinates, mom)\n  LorentzVectorBase.py(cs, mom) / LorentzVectorBase.pt(cs, mom)\nend","category":"page"},{"location":"generated/21-new_coord_system/#4.-Using-the-coordinate-system","page":"New Coordinate System","title":"4. Using the coordinate system","text":"","category":"section"},{"location":"generated/21-new_coord_system/","page":"New Coordinate System","title":"New Coordinate System","text":"To use LightConeCoordinates, a Lorentz vector type needs to:","category":"page"},{"location":"generated/21-new_coord_system/","page":"New Coordinate System","title":"New Coordinate System","text":"Implement coordinate_system(::MyVectorType) = LightConeCoordinates()\nImplement the four getters listed in coordinate_names: plus_component, minus_component, x, y","category":"page"},{"location":"generated/21-new_coord_system/","page":"New Coordinate System","title":"New Coordinate System","text":"Once that’s done, all the functions we defined here will work automatically.","category":"page"},{"location":"generated/21-new_coord_system/","page":"New Coordinate System","title":"New Coordinate System","text":"","category":"page"},{"location":"generated/21-new_coord_system/","page":"New Coordinate System","title":"New Coordinate System","text":"This page was generated using Literate.jl.","category":"page"},{"location":"90-contributing/#contributing","page":"Contributors guide","title":"Contributing guidelines","text":"","category":"section"},{"location":"90-contributing/","page":"Contributors guide","title":"Contributors guide","text":"First of all, thanks for the interest!","category":"page"},{"location":"90-contributing/","page":"Contributors guide","title":"Contributors guide","text":"We welcome all kinds of contribution, including, but not limited to code, documentation, examples, configuration, issue creating, etc.","category":"page"},{"location":"90-contributing/","page":"Contributors guide","title":"Contributors guide","text":"Be polite and respectful, and follow the code of conduct.","category":"page"},{"location":"90-contributing/#Bug-reports-and-discussions","page":"Contributors guide","title":"Bug reports and discussions","text":"","category":"section"},{"location":"90-contributing/","page":"Contributors guide","title":"Contributors guide","text":"If you think you found a bug, feel free to open an issue. Focused suggestions and requests can also be opened as issues. Before opening a pull request, start an issue or a discussion on the topic, please.","category":"page"},{"location":"90-contributing/#Working-on-an-issue","page":"Contributors guide","title":"Working on an issue","text":"","category":"section"},{"location":"90-contributing/","page":"Contributors guide","title":"Contributors guide","text":"If you found an issue that interests you, comment on that issue what your plans are. If the solution to the issue is clear, you can immediately create a pull request (see below). Otherwise, say what your proposed solution is and wait for a discussion around it.","category":"page"},{"location":"90-contributing/","page":"Contributors guide","title":"Contributors guide","text":"tip: Tip\nIf you haven’t received a reply after a few days, don’t hesitate to follow up.","category":"page"},{"location":"90-contributing/","page":"Contributors guide","title":"Contributors guide","text":"If your solution involves code (or something that requires running the package locally), check the developer documentation. Otherwise, you can use the GitHub interface directly to create your pull request.","category":"page"},{"location":"#LorentzVectorBase.jl","page":"Home","title":"LorentzVectorBase.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Stable Documentation) (Image: In development documentation) (Image: Test workflow status) (Image: Docs workflow Status) (Image: Coverage)","category":"page"},{"location":"","page":"Home","title":"Home","text":"LorentzVectorBase.jl provides base interfaces for four-momenta in high-energy physics, facilitating standardized representations and operations on Lorentz vectors.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install the package using Julia's package manager:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\nPkg.add(\"LorentzVectorBase\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Alternatively, in the Julia REPL, enter pkg> mode by typing ], then","category":"page"},{"location":"","page":"Home","title":"Home","text":"add LorentzVectorBase","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package defines abstract interfaces for Lorentz vectors. To utilize concrete implementations, consider packages like LorentzVectorHEP.jl or FourVectors.jl.","category":"page"},{"location":"#Example","page":"Home","title":"Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The following example shows how to define a custom Lorentz vector type and implement the minimal set of interface functions required by LorentzVectorBase:","category":"page"},{"location":"","page":"Home","title":"Home","text":"struct CustomLVector\n    id::Int\n    x::Float64\n    y::Float64\n    z::Float64\n    t::Float64\nend\n\nLorentzVectorBase.coordinate_system(::CustomLVector) = LorentzVectorBase.XYZT()\nLorentzVectorBase.x(lv::CustomLVector) = lv.x\nLorentzVectorBase.y(lv::CustomLVector) = lv.y\nLorentzVectorBase.z(lv::CustomLVector) = lv.z\nLorentzVectorBase.t(lv::CustomLVector) = lv.t","category":"page"},{"location":"","page":"Home","title":"Home","text":"Your custom type can include any additional fields or logic as needed. In this example, an extra id field is included alongside the four-vector components:","category":"page"},{"location":"","page":"Home","title":"Home","text":"c = CustomLVector(rand(1:100), 1, 2, 3, 4)\n@assert isapprox(LorentzVectorBase.spatial_magnitude(c), sqrt(1^2 + 2^2 + 3^2))","category":"page"},{"location":"#Code-Formatting","page":"Home","title":"Code Formatting","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To maintain code consistency, format your code with:","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia --project=.formatting -e 'using Pkg; Pkg.instantiate(); include(\".formatting/format_all.jl\")'","category":"page"},{"location":"","page":"Home","title":"Home","text":"This ensures adherence to the project's formatting standards.","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This project is licensed under the MIT License.","category":"page"}]
}
