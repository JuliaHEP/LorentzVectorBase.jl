var documenterSearchIndex = {"docs":
[{"location":"91-dev_docs/#dev_docs","page":"Developer docs","title":"Developer documentation","text":"note: Contributing guidelines\nIf you haven't, please read the Contributing guidelines first.\n\nIf you want to make contributions to this package that involves code, then this guide is for you.","category":"section"},{"location":"91-dev_docs/#First-time-clone","page":"Developer docs","title":"First time clone","text":"tip: If you have write access to the repository\nIf you have write access you don't have to fork. Instead, simply clone and skip ahead. Whenever upstream is mentioned, use origin instead. This also allows pull requests to push a preview of the docs.\n\nIf this is the first time you work with this repository, follow the instructions below to clone the repository.\n\nFork this repo\nClone your repo (this will create a git remote called origin)\nAdd this repo as a remote:\nbash  git remote add upstream https://github.com/JuliaHEP/LorentzVectorBase.jl.git\n\nThis will ensure that you have two remotes in your git: origin and upstream. You will create branches and push to origin, and you will fetch and update your local main branch from upstream.","category":"section"},{"location":"91-dev_docs/#Code-Formatting","page":"Developer docs","title":"Code Formatting","text":"To maintain code consistency, format your code with:\n\njulia --project=.formatting -e 'using Pkg; Pkg.instantiate(); include(\".formatting/format_all.jl\")'\n\nThis ensures adherence to the project's formatting standards.","category":"section"},{"location":"91-dev_docs/#Testing","page":"Developer docs","title":"Testing","text":"As with most Julia packages, you can just open Julia in the repository folder, activate the environment, and run test:\n\njulia> # press ]\npkg> activate .\npkg> test","category":"section"},{"location":"91-dev_docs/#Working-on-a-new-issue","page":"Developer docs","title":"Working on a new issue","text":"We try to keep a linear history in this repo, so it is important to keep your branches up-to-date.\n\nFetch from the remote and fast-forward your local main\nbash  git fetch upstream  git switch main  git merge --ff-only upstream/main\nBranch from main to address the issue (see below for naming)\nbash  git switch -c 42-add-answer-universe\nPush the new local branch to your personal remote repository\nbash  git push -u origin 42-add-answer-universe\nCreate a pull request to merge your remote branch into the org main.","category":"section"},{"location":"91-dev_docs/#Branch-naming","page":"Developer docs","title":"Branch naming","text":"If there is an associated issue, add the issue number.\nIf there is no associated issue, and the changes are small, add a prefix such as \"typo\", \"hotfix\", \"small-refactor\", according to the type of update.\nIf the changes are not small and there is no associated issue, then create the issue first, so we can properly discuss the changes.\nUse dash separated imperative wording related to the issue (e.g., 14-add-tests, 15-fix-model, 16-remove-obsolete-files).","category":"section"},{"location":"91-dev_docs/#Commit-message","page":"Developer docs","title":"Commit message","text":"Use imperative or present tense, for instance: Add feature or Fix bug.\nHave informative titles.\nWhen necessary, add a body with details.\nIf there are breaking changes, add the information to the commit message.","category":"section"},{"location":"91-dev_docs/#Before-creating-a-pull-request","page":"Developer docs","title":"Before creating a pull request","text":"tip: Atomic git commits\nTry to create \"atomic git commits\" (recommended reading: The Utopic Git History).\n\nMake sure the tests pass.\nFetch any main updates from upstream and rebase your branch, if necessary:\nbash   git fetch upstream   git rebase upstream/main BRANCH_NAME\nThen you can open a pull request and work with the reviewer to address any issues.","category":"section"},{"location":"91-dev_docs/#Building-and-viewing-the-documentation-locally","page":"Developer docs","title":"Building and viewing the documentation locally","text":"Following the latest suggestions, we recommend using LiveServer to build the documentation. Here is how you do it:\n\nRun julia --project=docs to open Julia in the environment of the docs.\nIf this is the first time building the docs\nPress ] to enter pkg mode\nRun pkg> dev . to use the development version of your package\nPress backspace to leave pkg mode\nRun julia> using LiveServer\nRun julia> servedocs()","category":"section"},{"location":"91-dev_docs/#Making-a-new-release","page":"Developer docs","title":"Making a new release","text":"To create a new release, you can follow these simple steps:\n\nCreate a branch release-x.y.z\nUpdate version in Project.toml\nCreate a commit \"Release vx.y.z\", push, create a PR, wait for it to pass, merge the PR.\nGo back to main screen and click on the latest commit (link: https://github.com/JuliaHEP/LorentzVectorBase.jl/commit/main)\nAt the bottom, write @JuliaRegistrator register\n\nAfter that, you only need to wait and verify:\n\nWait for the bot to comment (should take < 1m) with a link to a PR to the registry\nFollow the link and wait for a comment on the auto-merge\nThe comment should said all is well and auto-merge should occur shortly\nAfter the merge happens, TagBot will trigger and create a new GitHub tag. Check on https://github.com/JuliaHEP/LorentzVectorBase.jl/releases\nAfter the release is created, a \"docs\" GitHub action will start for the tag.\nAfter it passes, a deploy action will run.\nAfter that runs, the stable docs should be updated. Check them and look for the version number.","category":"section"},{"location":"95-reference/#reference","page":"API Reference","title":"Reference","text":"","category":"section"},{"location":"95-reference/#Contents","page":"API Reference","title":"Contents","text":"Pages = [\"95-reference.md\"]","category":"section"},{"location":"95-reference/#Index","page":"API Reference","title":"Index","text":"Pages = [\"95-reference.md\"]","category":"section"},{"location":"95-reference/#Interface","page":"API Reference","title":"Interface","text":"","category":"section"},{"location":"95-reference/#Supported-coordinate-systems","page":"API Reference","title":"Supported coordinate systems","text":"","category":"section"},{"location":"95-reference/#Supported-getter-functions","page":"API Reference","title":"Supported getter functions","text":"","category":"section"},{"location":"95-reference/#Utility","page":"API Reference","title":"Utility","text":"","category":"section"},{"location":"95-reference/#LorentzVectorBase.coordinate_system","page":"API Reference","title":"LorentzVectorBase.coordinate_system","text":"coordinate_system(::MomType)::CS where {CS <: AbstractCoordinateSystem}\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.coordinate_names","page":"API Reference","title":"LorentzVectorBase.coordinate_names","text":"coordinate_names(::AbstractCoordinateSystem)::Tuple{Symbols}\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.XYZT","page":"API Reference","title":"LorentzVectorBase.XYZT","text":"XYZT <: AbstractCoordinateSystem\n\nRepresents the Cartesian coordinate system for four-vectors, where the components are labeled as (x, y, z, t).\n\nTo use this coordinate system with a custom four-vector type, you must implement the following interface methods:\n\nLorentzVectorBase.x(::CustomFourVector)  # Returns the x-component\nLorentzVectorBase.y(::CustomFourVector)  # Returns the y-component\nLorentzVectorBase.z(::CustomFourVector)  # Returns the z-component\nLorentzVectorBase.t(::CustomFourVector)  # Returns the time component\n\nExample\n\nThe following example demonstrates how to define a custom four-vector type and implement the required interface:\n\njulia> struct CustomLVector\n           x\n           y\n           z\n           t\n       end\n\njulia> LorentzVectorBase.coordinate_system(::CustomLVector) = LorentzVectorBase.XYZT()\n\njulia> LorentzVectorBase.x(lv::CustomLVector) = lv.x\n\njulia> LorentzVectorBase.y(lv::CustomLVector) = lv.y\n\njulia> LorentzVectorBase.z(lv::CustomLVector) = lv.z\n\njulia> LorentzVectorBase.t(lv::CustomLVector) = lv.t\n\njulia> c = CustomLVector(1, 2, 3, 4)\nCustomLVector(1, 2, 3, 4)\n\njulia> @assert isapprox(LorentzVectorBase.spatial_magnitude(c), sqrt(1^2 + 2^2 + 3^2))\n\n\nBy implementing these methods, the custom type CustomLVector becomes compatible with LorentzVectorBase operations in the XYZT coordinate system.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LorentzVectorBase.PxPyPzE","page":"API Reference","title":"LorentzVectorBase.PxPyPzE","text":"PxPyPzE <: AbstractCoordinateSystem\n\nRepresents the Cartesian coordinate system for four-momenta, where the components are labeled as (px, py, pz, E). This system is commonly used in high-energy physics to describe the momentum and energy of particles.\n\nTo use this coordinate system with a custom four-momentum type, you must implement the following interface methods:\n\nLorentzVectorBase.px(::CustomFourMomentum)  # Returns the x-component of momentum\nLorentzVectorBase.py(::CustomFourMomentum)  # Returns the y-component of momentum\nLorentzVectorBase.pz(::CustomFourMomentum)  # Returns the z-component of momentum\nLorentzVectorBase.E(::CustomFourMomentum)   # Returns the energy component\n\nExample\n\nThe following example demonstrates how to define a custom four-momentum type and implement the required interface:\n\njulia> struct CustomFourMomentum\n           px\n           py\n           pz\n           E\n       end\n\njulia> LorentzVectorBase.coordinate_system(::CustomFourMomentum) = LorentzVectorBase.PxPyPzE()\n\njulia> LorentzVectorBase.px(p::CustomFourMomentum) = p.px\n\njulia> LorentzVectorBase.py(p::CustomFourMomentum) = p.py\n\njulia> LorentzVectorBase.pz(p::CustomFourMomentum) = p.pz\n\njulia> LorentzVectorBase.E(p::CustomFourMomentum) = p.E\n\njulia> p = CustomFourMomentum(1.0, 2.0, 3.0, 4.0)\nCustomFourMomentum(1.0, 2.0, 3.0, 4.0)\n\njulia> isapprox(LorentzVectorBase.spatial_magnitude(p), sqrt(1.0^2 + 2.0^2 + 3.0^2))\ntrue\n\n\nBy implementing these methods, the custom type CustomFourMomentum becomes compatible with LorentzVectorBase operations in the PxPyPzE coordinate system.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LorentzVectorBase.PtEtaPhiM","page":"API Reference","title":"LorentzVectorBase.PtEtaPhiM","text":"PtEtaPhiM <: AbstractCoordinateSystem\n\nRepresents the cylindrical coordinate system for four-momenta, commonly used in high-energy physics. This system expresses four-momentum components in terms of transverse momentum (pt), pseudorapidity (eta), azimuthal angle (phi), and mass (mass).\n\nTo use this coordinate system with a custom four-momentum type, you must implement the following interface methods:\n\nLorentzVectorBase.pt(::CustomFourMomentum)    # Returns the transverse momentum\nLorentzVectorBase.eta(::CustomFourMomentum)   # Returns the pseudorapidity\nLorentzVectorBase.phi(::CustomFourMomentum)   # Returns the azimuthal angle\nLorentzVectorBase.mass(::CustomFourMomentum)  # Returns the mass\n\nExample\n\nThe following example demonstrates how to define a custom four-momentum type and implement the required interface:\n\njulia> struct CustomFourMomentum\n           pt\n           eta\n           phi\n           mass\n       end\n\njulia> LorentzVectorBase.coordinate_system(::CustomFourMomentum) = LorentzVectorBase.PtEtaPhiM()\n\njulia> LorentzVectorBase.pt(p::CustomFourMomentum) = p.pt\n\njulia> LorentzVectorBase.eta(p::CustomFourMomentum) = p.eta\n\njulia> LorentzVectorBase.phi(p::CustomFourMomentum) = p.phi\n\njulia> LorentzVectorBase.mass(p::CustomFourMomentum) = p.mass\n\njulia> p = CustomFourMomentum(10.0, 2.5, 1.57, 0.105)\nCustomFourMomentum(10.0, 2.5, 1.57, 0.105)\n\njulia> isapprox(LorentzVectorBase.polar_angle(p), 2 * atan(exp(-2.5)))\ntrue\n\n\nBy implementing these methods, the custom type CustomFourMomentum becomes compatible with LorentzVectorBase operations in the PtEtaPhiM coordinate system.\n\n\n\n\n\n","category":"type"},{"location":"95-reference/#LorentzVectorBase.x","page":"API Reference","title":"LorentzVectorBase.x","text":"x(lv)\n\nReturn the x-component (first spatial component) of the Lorentz-vector-like lv.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.y","page":"API Reference","title":"LorentzVectorBase.y","text":"y(lv)\n\nReturn the y-component (second spatial component) of the Lorentz-vector-like lv.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.z","page":"API Reference","title":"LorentzVectorBase.z","text":"z(lv)\n\nReturn the z-component (third spatial component) of the Lorentz-vector-like lv.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.t","page":"API Reference","title":"LorentzVectorBase.t","text":"t(lv)\n\nReturn the time (energy) component of the Lorentz-vector-like lv.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.px","page":"API Reference","title":"LorentzVectorBase.px","text":"px(lv)\n\nReturn the x-component of a given Lorentz-vector-like lv.\n\nExample\n\nFor a four-momentum `(px, py, pz, E)`, this function returns the `px` component.\n\nSee Also\n\nLorentzVectorBase.x: The x-component of a Lorentz-vector-like, which is equivalent to px.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.py","page":"API Reference","title":"LorentzVectorBase.py","text":"py(lv)\n\nReturn the y-component of a given Lorentz-vector-like lv.\n\nExample\n\nFor a four-momentum (px, py, pz, E), this function returns the py component.\n\nSee Also\n\nLorentzVectorBase.y: The y-component of a Lorentz-vector-like, which is equivalent to py.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.pz","page":"API Reference","title":"LorentzVectorBase.pz","text":"pz(lv)\n\nReturn the z-component of a given Lorentz-vector-like lv.\n\nExample\n\nFor a four-momentum (px, py, pz, E), this function returns the pz component.\n\nSee Also\n\nLorentzVectorBase.z: The z-component of a Lorentz-vector-like, which is equivalent to pz.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.E","page":"API Reference","title":"LorentzVectorBase.E","text":"E(lv)\n\nReturn the energy component (E) of a given Lorentz-vector-like lv.\n\nExample\n\nFor a four-momentum (px, py, pz, E), this function returns the E component.\n\nSee Also\n\nLorentzVectorBase.t: The time component of a Lorentz-vector-like, which is equivalent to E.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.pt","page":"API Reference","title":"LorentzVectorBase.pt","text":"pt(lv)\n\nReturn the transverse momentum (p_T) of a given Lorentz-vector-like lv, defined as the Euclidean magnitude of the momentum components in the x-y plane.\n\nExample\n\nFor a four-momentum (px, py, pz, E), this function returns \\sqrt(px^2 + py^2).\n\nNotes\n\nThe transverse components are defined with respect to the z-axis (3-axis), representing the perpendicular momentum to this axis.\n\nSee Also\n\npt2: For the squared transverse momentum.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.pt2","page":"API Reference","title":"LorentzVectorBase.pt2","text":"pt2(lv)\n\nReturn the squared transverse momentum (p_T^2) of a given Lorentz-vector-like lv. The transverse momentum is defined with respect to the z-axis (3-axis) and is the sum of the squares of the x- and y-components.\n\nExample\n\nFor a four-momentum (px, py, pz, E), this function returns px^2 + py^2.\n\nNotes\n\nThe transverse components are the momentum projections in the x-y plane, perpendicular to the z-axis.\n\nSee Also\n\npt: For the transverse momentum.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.eta","page":"API Reference","title":"LorentzVectorBase.eta","text":"eta(lv)\n\nReturn the pseudorapidity (eta) of a given Lorentz-vector-like lv. The pseudorapidity is a commonly used quantity in high-energy physics, particularly in collider experiments, and is defined as:\n\n    eta = -log(tan(theta 2))\n\nwhere theta is the polar angle of the Lorentz-vector-like relative to the z-axis.\n\nExample\n\nFor a four-momentum (px, py, pz, E), this function log(tan(theta/2)) where theta is given by the polar_angle.\n\nwarning: Warning\nIf the transverse momentum (pt) is zero (i.e., the particle is aligned with the beam axis), a warning is raised, and a large pseudorapidity value (±10e10) is returned as a convention. This occurs because the pseudorapidity is ill-defined when pt = 0.\n\nNotes\n\nPseudorapidity is approximately equal to the rapidity y in the ultra-relativistic limit   (when the particle's mass is negligible compared to its energy).\n\nSee Also\n\nrapidity: For the rapidity of the Lorentz-vector-like.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.phi","page":"API Reference","title":"LorentzVectorBase.phi","text":"phi(lv)\n\nReturn the azimuthal angle (phi) of the Lorentz-vector-like lv.\n\nThe azimuthal angle is the angle between the x-axis and the projection of the Lorentz-vector-like on the x-y plane.\n\nExample\n\nIf ``(x, y, z, t)`` is a four-vector, this is equivalent to ``atan(y / x)``.\n\nnote: Note\nThe azimuthal angle is defined with respect to the z-axis.\n\nSee Also\n\nLorentzVectorBase.sin_phi: for a faster version of the sine of the azimuthal angle.\nLorentzVectorBase.cos_phi: for a faster version of the cosine of the azimuthal angle.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.spatial_magnitude","page":"API Reference","title":"LorentzVectorBase.spatial_magnitude","text":"spatial_magnitude(lv)\n\nReturn the spatial magnitude of the Lorentz-vector-like lv, i.e., the magnitude of its spatial components.\n\nExample\n\nIf the Lorentz-vector-like is a four-vector (x, y, z, t), this function returns \\sqrt(x^2 + y^2 + z^2).\n\nwarning: Warning\nThis function differs from the TLorentzVector::P() function in the ROOT library.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.spatial_magnitude2","page":"API Reference","title":"LorentzVectorBase.spatial_magnitude2","text":"spatial_magnitude2(lv)\n\nReturn the square of the spatial magnitude of the Lorentz-vector-like lv, i.e., the sum of the squares of its spatial components.\n\nExample\n\nIf the Lorentz-vector-like is four-vector (x, y, z, t), this function returns x^2 + y^2 + z^2.\n\nwarning: Warning\nThis function differs from the TLorentzVector::P2() function in the ROOT library.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.mass","page":"API Reference","title":"LorentzVectorBase.mass","text":"mass(lv)\n\nReturn the invariant mass  of the Lorentz-vector-like lv, computed as the square root of the Minkowski inner product of the four-vector components with itself.\n\nExample\n\nFor a four-momentum (px, py, pz, E), this function returns \\sqrt(E^2 - (px^2 + py^2 + pz^2)).\n\nNotes\n\nIf the squared invariant mass m^2 is negative, this function returns -\\sqrt(-m^2) to ensure a real result. This can happen in certain unphysical cases where the energy component is smaller than the spatial momentum magnitude.\n\nSee Also\n\nmass2: For the squared invariant mass calculation.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.mass2","page":"API Reference","title":"LorentzVectorBase.mass2","text":"mass2(lv)\n\nReturn the squared invariant mass of the Lorentz-vector-like lv, computed as the Minkowski inner product of the four-vector components with itself.\n\nExample\n\nFor a four-momentum (px, py, pz, E), this function returns E^2 - (px^2 + py^2 + pz^2).\n\nSee Also\n\nmass: For the invariant mass, i.e., the square root of this value.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.boost_beta","page":"API Reference","title":"LorentzVectorBase.boost_beta","text":"boost_beta(lv)\n\nReturn the magnitude of the velocity (beta) of a particle as a fraction of the speed of light of the Lorentz-vector-like lv.\n\nExample\n\nFor a four-momentum (px, py, pz, E), this function returns \\sqrt(px^2 + py^2 + pz^2) / E.\n\nThrows\n\nArgumentError if the time (energy) component is zero while the spatial components are non-zero, as this results in an undefined velocity.\n\nNotes\n\nIf both the time (energy) and spatial components are zero, the function returns zero (beta = 0), as this represents a stationary object with no motion.\n\nSee Also\n\nboost_gamma: For the relativistic gamma factor, which depends on beta.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.boost_gamma","page":"API Reference","title":"LorentzVectorBase.boost_gamma","text":"boost_gamma(lv)\n\nReturn the relativistic gamma factor (gamma) for the Lorentz-vector-like lv.\n\nExample\n\nFor a four-momentum (px, py, pz, E) with velocity beta, this function returns 1  sqrt(1 - beta^2).\n\nSee Also\n\nboost_beta: For the velocity beta, which is used to compute gamma.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.mt2","page":"API Reference","title":"LorentzVectorBase.mt2","text":"mt2(lv)\n\nReturn the squared transverse mass (m_T^2) of a given Lorentz-vector-like lv, which is the difference between the squared time- (energy-) and the squared z-component.\n\nExample\n\nFor a four-momentum (px, py, pz, E), this function returns E^2 - pz^2.\n\nNotes\n\nThe transverse components are defined with respect to the z-axis (3-axis), indicating a projection in the x-y plane.\n\nSee Also\n\nmt: For the transverse mass.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.mt","page":"API Reference","title":"LorentzVectorBase.mt","text":"mt(lv)\n\nReturn the transverse mass (m_T) of a given Lorentz-vector-like lv, calculated as the square root of the squared transverse mass. The transverse mass is often used in high-energy physics to describe the effective mass of a system when only the transverse components are considered.\n\nExample\n\nFor a four-momentum (px, py, pz, E), this function returns \\sqrt(E^2 - pz^2).\n\nNotes\n\nIf the squared transverse mass (mT^2) is negative, the function returns -\\sqrt(-mT^2) to\n\nhandle the imaginary mass situation that can occur in some relativistic systems.\n\nThe transverse components are defined with respect to the z-axis (3-axis), indicating momentum in the x-y plane.\n\nThrows\n\nMay include a warning if the transverse mass is negative, depending on user settings.\n\nSee Also\n\nmt2: For the squared transverse mass.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.rapidity","page":"API Reference","title":"LorentzVectorBase.rapidity","text":"rapidity(lv)\n\nReturn the rapidity for a given Lorentz-vector-like lv.\n\nThe rapidity y is defined as:\n\ny = frac12log((E + p_z)  (E - p_z))\n\nwhere E is the energy (time- or 0-component of the Lorentz-vector-like), and pz is the component along the z-axis.\n\nExample\n\nFor a four-vector (px, py, pz, E), this function calculates the rapidity as:\n\ny = 0.5 * log((E + pz) / (E - pz))\n\nNotes\n\nRapidity is preferred over pseudorapidity when mass effects are significant, as it takes   into account the energy and longitudinal momentum of the particle. In contrast, pseudorapidity   depends only on the particle's direction and ignores mass.\nThe transverse components of the momentum are defined with respect to the 3-axis (beam axis).\nRapidity is Lorentz-invariant under boosts along the z-axis, making it useful for comparisons   between different reference frames in collider experiments.\n\nwarning: Warning\nIf the particle's energy E is equal to its longitudinal momentum pz, resulting in a denominator of zero in the logarithm, the function will raise an error as rapidity is ill-defined in this case.\n\nSee Also\n\nLorentzVectorBase.eta: For the pseudorapidity of the Lorentz-vector-like.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.polar_angle","page":"API Reference","title":"LorentzVectorBase.polar_angle","text":"polar_angle(lv)\n\nReturn the polar angle (theta) of the Lorentz-vector-like lv.\n\nExample\n\nIf the Lorentz-vector-like is a four-vector (x y z t), this is equivalent to arccos(z  sqrtx^2 + y^2 + z^2).\n\nnote: Note\nIf the Lorentz-vector-like is zero, the function returns zero for the angle.\n\nSee Also\n\nLorentzVectorBase.cos_theta: for a faster version of the cosine of the polar angle.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.cos_theta","page":"API Reference","title":"LorentzVectorBase.cos_theta","text":"cos_theta(lv)\n\nReturn the cosine of the polar angle (theta) of the Lorentz-vector-like lv.\n\nDepending on the coordinate system, this might be an equivalent but faster version of cos(polar_angle(lv)).\n\nExample\n\nIf (x y z t) is a four-vector, this is equivalent to z  sqrtx^2 + y^2 + z^2.\n\nSee Also\n\nLorentzVectorBase.polar_angle: for the polar angle itself.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.cos_phi","page":"API Reference","title":"LorentzVectorBase.cos_phi","text":"cos_phi(lv)\n\nReturn the cosine of the azimuthal angle (phi) of the Lorentz-vector-like lv.\n\nDepending on the coordinate system, this might be an equivalent but faster version of cos(phi(lv)).\n\nExample\n\nIf (x y z t) is a four-momentum, this is equivalent to x  sqrtx^2 + y^2.\n\nSee Also\n\nLorentzVectorBase.phi: for the azimuthal angle itself.\nLorentzVectorBase.sin_phi: for a faster version of the sine of the azimuthal angle.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.sin_phi","page":"API Reference","title":"LorentzVectorBase.sin_phi","text":"sin_phi(lv)\n\nReturn the sine of the azimuthal angle (phi) of the Lorentz-vector-like lv.\n\nDepending on the coordinate system, this might be an equivalent but faster version of sin(phi(lv)).\n\nExample\n\nIf (x y z t) is a four-momentum, this is equivalent to y  sqrtx^2 + y^2.\n\nSee Also\n\nLorentzVectorBase.phi: for the azimuthal angle itself.\nLorentzVectorBase.cos_phi: for a faster version of the cosine of the azimuthal angle.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.plus_component","page":"API Reference","title":"LorentzVectorBase.plus_component","text":"plus_component(lv)\n\nReturn the plus component (p^+) of the Lorentz-vector-like lv in light-cone coordinates.\n\nThis component is defined as (t + z) / 2, where t is the time (or energy) component and z is the third spatial component of the Lorentz-vector-like.\n\nExample\n\nIf (x, y, z, t) is a four-vector, this is equivalent to (t + z) / 2.\n\nwarning: Warning\nThis definition differs from the light-cone coordinate definitions commonly used in general relativity.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.minus_component","page":"API Reference","title":"LorentzVectorBase.minus_component","text":"minus_component(lv)\n\nReturn the minus component (p^-) of the Lorentz-vector-like lv in light-cone coordinates.\n\nThis component is defined as (t - z) / 2, where t is the time (or energy) component and z is the third spatial component of the Lorentz-vector-like.\n\nExample\n\nIf (x, y, z, t) is a four-vector, this is equivalent to (t - z) / 2.\n\nwarning: Warning\nThis definition differs from the light-cone coordinate definitions commonly used in general relativity.\n\n\n\n\n\n","category":"function"},{"location":"95-reference/#LorentzVectorBase.available_accessors","page":"API Reference","title":"LorentzVectorBase.available_accessors","text":"available_accessors()\n\nReturns a list of available accessor functions for four-momentum components.\n\nThis function gathers all defined accessor methods (such as px, py, pz, E, etc.) that are available for any custom four-momentum type implementing the LorentzVectorBase interface.\n\nExample\n\njulia> LorentzVectorBase.available_accessors()\n38-element Vector{Symbol}:\n :x\n :y\n :z\n :t\n :energy\n :px\n :py\n ...\n\nThis allows users to query which accessor functions are available for any custom four-momentum type.\n\n\n\n\n\n","category":"function"},{"location":"10-interface/#interface","page":"Interface","title":"LorentzVectorBase Interface","text":"The LorentzVectorBase package defines a common interface for LorentzVectorBase-compliant types in Julia. This interface allows developers to define their own custom four-vector types (e.g., for particles or kinematic configurations) and automatically gain access to a large suite of common kinematic computations. For maximum flexibility, it is not necessary to inherit from an abstract base type.","category":"section"},{"location":"10-interface/#Purpose","page":"Interface","title":"Purpose","text":"The main goal is to provide a lightweight abstraction that enables:\n\nInteroperability between different packages using Lorentz vectors\nAutomatic derivation of many derived quantities (e.g. p_T, eta, m) from a minimal interface\nCoordinate system flexibility while maintaining performance","category":"section"},{"location":"10-interface/#Defining-a-Lorentz-Vector-Like-Type","page":"Interface","title":"Defining a Lorentz-Vector-Like Type","text":"To make your type compliant with LorentzVectorBase, you must:\n\nAssign a coordinate system using:\n\nLorentzVectorBase.coordinate_system(::MyVector) = XYZT()\n\nCoordinate systems are tagged using constructors like XYZT(), PtEtaPhiE(), etc. These indicate how the four components are interpreted.\n\nImplement the four accessors required by the chosen coordinate system.\n\nFor example, with XYZT():\n\nx(::MyVector)\ny(::MyVector)\nz(::MyVector)\nt(::MyVector)\n\nYou can inspect the required accessors for a given coordinate system using:\n\ncoordinate_names(XYZT())  # returns (:x, :y, :z, :t)\n\nThis indicates which component accessors your type must implement to be compliant with that system.\n\nThat's it! Once those are defined, the LorentzVectorBase package will automatically provide implementations for a wide variety of additional kinematic functions and coordinate conversions.","category":"section"},{"location":"10-interface/#getter","page":"Interface","title":"What You Get Automatically","text":"Once a minimal interface is implemented, the following functions become available (among others), categorized by topic:","category":"section"},{"location":"10-interface/#Cartesian-Components","page":"Interface","title":"Cartesian Components","text":"x, y, z, t\npx, py, pz, E","category":"section"},{"location":"10-interface/#Spherical-and-Cylindrical-Coordinates","page":"Interface","title":"Spherical and Cylindrical Coordinates","text":"spatial_magnitude, spatial_magnitude2\npolar_angle, cos_theta\nphi, cos_phi, sin_phi","category":"section"},{"location":"10-interface/#Mass-and-Invariant-Quantities","page":"Interface","title":"Mass and Invariant Quantities","text":"mass, mass2\nmt, mt2\npt, pt2","category":"section"},{"location":"10-interface/#Rapidity-and-Related-Quantities","page":"Interface","title":"Rapidity and Related Quantities","text":"eta: pseudorapidity\nrapidity","category":"section"},{"location":"10-interface/#Boost-Parameters","page":"Interface","title":"Boost Parameters","text":"boost_beta, boost_gamma","category":"section"},{"location":"10-interface/#Light-Cone-Coordinates","page":"Interface","title":"Light-Cone Coordinates","text":"plus_component, minus_component","category":"section"},{"location":"10-interface/#Accessor-Aliases","page":"Interface","title":"Accessor Aliases","text":"To improve readability and interoperability, LorentzVectorBase provides a set of aliases for common physics terminology. These aliases map frequently used or alternative names to the canonical accessor functions.\n\nFor example, energy is an alias for t, and invariant_mass maps to mass.\n\nenergy(lv)           === t(lv)\ninvariant_mass(lv)   === mass(lv)\ntransverse_momentum(lv) === pt(lv)\n\nThis allows users to choose more descriptive or domain-specific terminology without losing compatibility.","category":"section"},{"location":"10-interface/#Available-Aliases","page":"Interface","title":"Available Aliases","text":"Alias Canonical Function\nenergy t\ninvariant_mass mass\ninvariant_mass2 mass2\ntransverse_momentum pt\ntransverse_momentum2 pt2\nperp pt\nperp2 pt2\ntransverse_mass mt\ntransverse_mass2 mt2\nazimuthal_angle phi\npseudorapidity eta\n\nNote, that most of the package functions are not exported. They can always be called with LorentzVectorBase. prefix. For convenience, these methods can be exported in custom packages that utilize LorentzVectorBase. For example, as follows,\n\nmodule Custom4Vector\n\nimport LorentzVectorBase: invariant_mass\nexport invariant_mass\n\nend\n\nSee also an example of exporting multiple selected methods in a loop.","category":"section"},{"location":"10-interface/#Coordinate-System-Tags","page":"Interface","title":"Coordinate System Tags","text":"The following coordinate systems are supported via tags like XYZT(), PtEtaPhiM(), etc.:\n\nXYZT, PxPyPzE — position/time or cartesian four-momentum\nPtEtaPhiM — common in collider physics\n\nEach tag specifies which component names (x, pt, eta, etc.) you must implement.","category":"section"},{"location":"10-interface/#Example","page":"Interface","title":"Example","text":"struct MyVector\n    px::Float64\n    py::Float64\n    pz::Float64\n    E::Float64\nend\n\nLorentzVectorBase.coordinate_system(::MyVector) = PxPyPzE()\n\nLorentzVectorBase.px(v::MyVector) = v.px\nLorentzVectorBase.py(v::MyVector) = v.py\nLorentzVectorBase.pz(v::MyVector) = v.pz\nLorentzVectorBase.energy(v::MyVector) = v.E\n\nNow your type supports:\n\nmass(MyVector(...))\neta(MyVector(...))\npt(MyVector(...))\nphi(MyVector(...))\n\nwithout implementing them manually.","category":"section"},{"location":"generated/20-new_four_vector/#Implementing-the-LorentzVectorBase-Interface","page":"New Four-Vector","title":"Implementing the LorentzVectorBase Interface","text":"This tutorial demonstrates how to make a custom Julia type compatible with the LorentzVectorBase interface. Once your type implements the minimal required methods, you gain access to a rich suite of automatically derived kinematic functions such as mass, pt, rapidity, phi, and many others. See here for a complete list.","category":"section"},{"location":"generated/20-new_four_vector/#Step-1:-Load-the-package","page":"New Four-Vector","title":"Step 1: Load the package","text":"using LorentzVectorBase","category":"section"},{"location":"generated/20-new_four_vector/#Step-2:-Define-your-custom-Lorentz-vector-type","page":"New Four-Vector","title":"Step 2: Define your custom Lorentz vector type","text":"Let's define a simple concrete type representing a four-momentum vector using Cartesian coordinates: x, y, z, and t.\n\nstruct MyVector\n  x::Float64\n  y::Float64\n  z::Float64\n  t::Float64\nend","category":"section"},{"location":"generated/20-new_four_vector/#Step-3:-Specify-the-coordinate-system","page":"New Four-Vector","title":"Step 3: Specify the coordinate system","text":"Next, we tell LorentzVectorBase which coordinate system our type uses. Since MyVector stores its components in Cartesian momentum form, we declare:\n\nLorentzVectorBase.coordinate_system(::MyVector) = LorentzVectorBase.XYZT()\n\nThe tag XYZT() indicates a four-momentum representation with components (x, y, z, t).","category":"section"},{"location":"generated/20-new_four_vector/#Step-4:-Implement-the-required-accessors","page":"New Four-Vector","title":"Step 4: Implement the required accessors","text":"Finally, we provide methods to extract the components expected by the XYZT coordinate system: x, y, z, and t.\n\nLorentzVectorBase.x(v::MyVector) = v.x\nLorentzVectorBase.y(v::MyVector) = v.y\nLorentzVectorBase.z(v::MyVector) = v.z\nLorentzVectorBase.t(v::MyVector) = v.t\n\nWith these definitions in place, MyVector now fully satisfies the LorentzVectorBase interface!","category":"section"},{"location":"generated/20-new_four_vector/#Step-5:-Use-the-derived-functionality","page":"New Four-Vector","title":"Step 5: Use the derived functionality","text":"Let's create an instance of our custom type and use some of the functionality that LorentzVectorBase now provides for free:\n\nusing LorentzVectorBase: mass, pt, eta, rapidity, phi\n\nv = MyVector(1.0, 2.0, 3.0, 4.0)\n\nmass(v) # Invariant mass\npt(v) # Transverse momentum\neta(v) # Pseudorapidity\nrapidity(v) # Rapidity\nphi(v) # Azimuthal angle","category":"section"},{"location":"generated/20-new_four_vector/#Optional:-Use-aliases-for-convenience","page":"New Four-Vector","title":"Optional: Use aliases for convenience","text":"The package also defines aliases like energy, invariant_mass, and transverse_momentum. These are mapped automatically to their canonical counterparts:\n\nusing LorentzVectorBase: energy, invariant_mass, transverse_momentum\n\nenergy(v) # Same as `t(v)` or `E(v)`\ninvariant_mass(v) # Same as `mass(v)`\ntransverse_momentum(v) # Same as `pt(v)`\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/21-new_coord_system/#Implementing-a-New-Coordinate-System-in-LorentzVectorBase.jl","page":"New Coordinate System","title":"Implementing a New Coordinate System in LorentzVectorBase.jl","text":"In LorentzVectorBase.jl, coordinate systems are independent of any concrete four-vector type.\n\nThis tutorial shows how to implement a light-cone coordinate system for four-momentum, so that any Lorentz vector type can use it — provided that type implements the coordinate-specific getter functions.","category":"section"},{"location":"generated/21-new_coord_system/#Light-cone-coordinates","page":"New Coordinate System","title":"Light-cone coordinates","text":"We'll define:\n\nplus_component  = (t + z) / √2\nminus_component = (t - z) / √2\nx\ny\n\nThe coordinate-specific getters will be:\n\nLorentzVectorBase.plus_component(v)\nLorentzVectorBase.minus_component(v)\nLorentzVectorBase.x(v)\nLorentzVectorBase.y(v)\n\nAll other kinematic quantities (mass, pt, eta, phi, etc.) will be defined once in the coordinate system and will work for any vector type implementing the coordinate getters.\n\nusing LorentzVectorBase","category":"section"},{"location":"generated/21-new_coord_system/#1.-Define-the-coordinate-system-type","page":"New Coordinate System","title":"1. Define the coordinate system type","text":"Coordinate systems are singletons and must be subtypes of AbstractCoordinateSystem.\n\nstruct LightConeCoordinates <: LorentzVectorBase.AbstractCoordinateSystem end","category":"section"},{"location":"generated/21-new_coord_system/#2.-Define-the-coordinate-names","page":"New Coordinate System","title":"2. Define the coordinate names","text":"coordinate_names returns the tuple of getter function names that must be implemented for any vector type using this coordinate system.\n\nfunction LorentzVectorBase.coordinate_names(::LightConeCoordinates)\n  return (:plus_component, :minus_component, :x, :y)\nend","category":"section"},{"location":"generated/21-new_coord_system/#3.-Implement-the-derived-kinematic-functions","page":"New Coordinate System","title":"3. Implement the derived kinematic functions","text":"The coordinate system must implement all relevant getter functions listed in FOURMOMENTUM_GETTER_FUNCTIONS, except those returned by coordinate_names.\n\nThese implementations are type-generic — they take a coordinate system instance and a mom (momentum object), and call only the coordinate-specific getters (plus_component, minus_component, x, y).\n\nconst SQRT2 = sqrt(2.0)\n\nCartesian component accessors\n\nfunction LorentzVectorBase.t(::LightConeCoordinates, mom)\n  return (LorentzVectorBase.plus_component(mom) + LorentzVectorBase.minus_component(mom)) /\n         SQRT2\nend\nfunction LorentzVectorBase.z(::LightConeCoordinates, mom)\n  return (LorentzVectorBase.plus_component(mom) - LorentzVectorBase.minus_component(mom)) /\n         SQRT2\nend\n\nMomentum magnitudes\n\nLorentzVectorBase.px(::LightConeCoordinates, mom) = LorentzVectorBase.x(mom)\nLorentzVectorBase.py(::LightConeCoordinates, mom) = LorentzVectorBase.y(mom)\nLorentzVectorBase.pz(::LightConeCoordinates, mom) = LorentzVectorBase.z(mom)\nLorentzVectorBase.E(::LightConeCoordinates, mom) = LorentzVectorBase.t(mom)\n\nfunction LorentzVectorBase.pt2(::LightConeCoordinates, mom)\n  return LorentzVectorBase.x(mom)^2 + LorentzVectorBase.y(mom)^2\nend\nLorentzVectorBase.pt(::LightConeCoordinates, mom) = sqrt(LorentzVectorBase.pt2(mom))\n\nfunction LorentzVectorBase.spatial_magnitude2(::LightConeCoordinates, mom)\n  return LorentzVectorBase.pt2(mom) + LorentzVectorBase.pz(mom)^2\nend\nfunction LorentzVectorBase.spatial_magnitude(::LightConeCoordinates, mom)\n  return sqrt(LorentzVectorBase.spatial_magnitude2(mom))\nend\n\nMass and energy-related\n\nfunction LorentzVectorBase.mass2(::LightConeCoordinates, mom)\n  return LorentzVectorBase.E(mom)^2 - LorentzVectorBase.spatial_magnitude2(mom)\nend\nfunction LorentzVectorBase.mass(::LightConeCoordinates, mom)\n  return sqrt(LorentzVectorBase.mass2(mom))\nend\n\nfunction LorentzVectorBase.boost_beta(::LightConeCoordinates, mom)\n  return LorentzVectorBase.spatial_magnitude(mom) / LorentzVectorBase.E(mom)\nend\nfunction LorentzVectorBase.boost_gamma(::LightConeCoordinates, mom)\n  return 1 / sqrt(1 - LorentzVectorBase.boost_beta(mom)^2)\nend\n\nfunction LorentzVectorBase.mt2(::LightConeCoordinates, mom)\n  return LorentzVectorBase.E(mom)^2 - LorentzVectorBase.pz(mom)^2\nend\nLorentzVectorBase.mt(::LightConeCoordinates, mom) = sqrt(LorentzVectorBase.mt2(mom))\n\nAngular coordinates\n\nfunction LorentzVectorBase.rapidity(::LightConeCoordinates, mom)\n  return 0.5 * log(\n    (LorentzVectorBase.E(mom) + LorentzVectorBase.pz(mom)) /\n    (LorentzVectorBase.E(mom) - LorentzVectorBase.pz(mom)),\n  )\nend\n\nfunction LorentzVectorBase.polar_angle(::LightConeCoordinates, mom)\n  return atan(LorentzVectorBase.pt(mom), LorentzVectorBase.pz(mom))\nend\n\nfunction LorentzVectorBase.cos_theta(::LightConeCoordinates, mom)\n  return LorentzVectorBase.pz(mom) / LorentzVectorBase.spatial_magnitude(mom)\nend\n\nfunction LorentzVectorBase.phi(::LightConeCoordinates, mom)\n  return atan(LorentzVectorBase.py(mom), LorentzVectorBase.px(mom))\nend\nfunction LorentzVectorBase.cos_phi(::LightConeCoordinates, mom)\n  return LorentzVectorBase.px(mom) / LorentzVectorBase.pt(mom)\nend\nfunction LorentzVectorBase.sin_phi(::LightConeCoordinates, mom)\n  return LorentzVectorBase.py(mom) / LorentzVectorBase.pt(mom)\nend","category":"section"},{"location":"generated/21-new_coord_system/#4.-Using-the-coordinate-system","page":"New Coordinate System","title":"4. Using the coordinate system","text":"To use LightConeCoordinates, a Lorentz vector type needs to:\n\nImplement coordinate_system(::MyVectorType) = LightConeCoordinates()\nImplement the four getters listed in coordinate_names: plus_component, minus_component, x, y\n\nOnce that’s done, all the functions we defined here will work automatically.\n\nFor example, here is a simple four-vector type using light-cone coordinates:\n\nstruct MyLightConeVector\n  plus::Float64\n  minus::Float64\n  x::Float64\n  y::Float64\nend\n\nLorentzVectorBase.coordinate_system(::MyLightConeVector) = LightConeCoordinates()\n\nLorentzVectorBase.plus_component(v::MyLightConeVector) = v.plus\nLorentzVectorBase.minus_component(v::MyLightConeVector) = v.minus\nLorentzVectorBase.x(v::MyLightConeVector) = v.x\nLorentzVectorBase.y(v::MyLightConeVector) = v.y\n\nLorentzVectorBase.E(MyLightConeVector(3.0, 1.0, 1.0, 2.0))  # works!\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"90-contributing/#contributing","page":"Contributors guide","title":"Contributing guidelines","text":"First of all, thanks for the interest!\n\nWe welcome all kinds of contribution, including, but not limited to code, documentation, examples, configuration, issue creating, etc.\n\nBe polite and respectful, and follow the code of conduct.","category":"section"},{"location":"90-contributing/#Bug-reports-and-discussions","page":"Contributors guide","title":"Bug reports and discussions","text":"If you think you found a bug, feel free to open an issue. Focused suggestions and requests can also be opened as issues. Before opening a pull request, start an issue or a discussion on the topic, please.","category":"section"},{"location":"90-contributing/#Working-on-an-issue","page":"Contributors guide","title":"Working on an issue","text":"If you found an issue that interests you, comment on that issue what your plans are. If the solution to the issue is clear, you can immediately create a pull request (see below). Otherwise, say what your proposed solution is and wait for a discussion around it.\n\ntip: Tip\nIf you haven’t received a reply after a few days, don’t hesitate to follow up.\n\nIf your solution involves code (or something that requires running the package locally), check the developer documentation. Otherwise, you can use the GitHub interface directly to create your pull request.","category":"section"},{"location":"#LorentzVectorBase.jl","page":"Home","title":"LorentzVectorBase.jl","text":"(Image: Stable Documentation) (Image: In development documentation) (Image: Test workflow status) (Image: Docs workflow Status) (Image: Coverage)\n\nLorentzVectorBase.jl provides base interfaces for four-momenta in high-energy physics, facilitating standardized representations and operations on Lorentz vectors.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"Install the package using Julia's package manager:\n\nusing Pkg\nPkg.add(\"LorentzVectorBase\")\n\nAlternatively, in the Julia REPL, enter pkg> mode by typing ], then\n\nadd LorentzVectorBase","category":"section"},{"location":"#Usage","page":"Home","title":"Usage","text":"This package defines abstract interfaces for Lorentz vectors. To utilize concrete implementations, consider packages like LorentzVectorHEP.jl or FourVectors.jl.","category":"section"},{"location":"#Example","page":"Home","title":"Example","text":"The following example shows how to define a custom Lorentz vector type and implement the minimal set of interface functions required by LorentzVectorBase:\n\nstruct CustomLVector\n    id::Int\n    x::Float64\n    y::Float64\n    z::Float64\n    t::Float64\nend\n\nLorentzVectorBase.coordinate_system(::CustomLVector) = LorentzVectorBase.XYZT()\nLorentzVectorBase.x(lv::CustomLVector) = lv.x\nLorentzVectorBase.y(lv::CustomLVector) = lv.y\nLorentzVectorBase.z(lv::CustomLVector) = lv.z\nLorentzVectorBase.t(lv::CustomLVector) = lv.t\n\nYour custom type can include any additional fields or logic as needed. In this example, an extra id field is included alongside the four-vector components:\n\nc = CustomLVector(rand(1:100), 1, 2, 3, 4)\n@assert isapprox(LorentzVectorBase.spatial_magnitude(c), sqrt(1^2 + 2^2 + 3^2))","category":"section"},{"location":"#Code-Formatting","page":"Home","title":"Code Formatting","text":"To maintain code consistency, format your code with:\n\njulia --project=.formatting -e 'using Pkg; Pkg.instantiate(); include(\".formatting/format_all.jl\")'\n\nThis ensures adherence to the project's formatting standards.","category":"section"},{"location":"#License","page":"Home","title":"License","text":"This project is licensed under the MIT License.","category":"section"}]
}
